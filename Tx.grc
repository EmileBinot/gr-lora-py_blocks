options:
  parameters:
    author: ''
    catch_exceptions: 'True'
    category: '[GRC Hier Blocks]'
    cmake_opt: ''
    comment: ''
    copyright: ''
    description: ''
    gen_cmake: 'On'
    gen_linking: dynamic
    generate_options: qt_gui
    hier_block_src_path: '.:'
    id: Tx
    max_nouts: '0'
    output_language: python
    placement: (0,0)
    qt_qss_theme: ''
    realtime_scheduling: ''
    run: 'True'
    run_command: '{python} -u {filename}'
    run_options: prompt
    sizing_mode: fixed
    thread_safe_setters: ''
    title: Not titled yet
    window_size: (1000,1000)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [8, 8]
    rotation: 0
    state: enabled

blocks:
- name: CR
  id: variable
  parameters:
    comment: ''
    value: '2'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [528, 28.0]
    rotation: 0
    state: enabled
- name: SF
  id: variable
  parameters:
    comment: ''
    value: '9'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [456, 28.0]
    rotation: 0
    state: enabled
- name: bandwidth
  id: variable
  parameters:
    comment: ''
    value: int(125e3)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [432, 92.0]
    rotation: 0
    state: enabled
- name: center_freq
  id: variable
  parameters:
    comment: ''
    value: int(868e6)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [520, 92.0]
    rotation: 0
    state: enabled
- name: frame_len
  id: variable
  parameters:
    comment: ''
    value: '18'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [344, 92.0]
    rotation: 0
    state: enabled
- name: preamble_len
  id: variable
  parameters:
    comment: ''
    value: '6'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [352, 28.0]
    rotation: 0
    state: enabled
- name: samp_rate
  id: variable
  parameters:
    comment: ''
    value: bandwidth
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [256, 28.0]
    rotation: 0
    state: enabled
- name: blocks_file_sink_0_3
  id: blocks_file_sink
  parameters:
    affinity: ''
    alias: ''
    append: 'False'
    comment: ''
    file: dumpIN
    type: byte
    unbuffered: 'False'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [248, 372.0]
    rotation: 0
    state: enabled
- name: blocks_message_strobe_0
  id: blocks_message_strobe
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    msg: pmt.intern("#t")
    period: '10000'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [96, 236.0]
    rotation: 0
    state: enabled
- name: blocks_vector_to_stream_0_0_1
  id: blocks_vector_to_stream
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    num_items: pow(2,SF)
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1032, 488.0]
    rotation: 0
    state: enabled
- name: epy_block_0_1_0_0
  id: epy_block
  parameters:
    CR: CR
    SF: SF
    _source_code: "\"\"\"\nInterleaving block\nScrambles bits together to fight error\
      \ bursts.\nReference : \"Towards an SDR implementation of LoRa...\" 2020 A.Marquet,\
      \ N.Montavont, G.Papadopoulos)\n\nINPUT:\n    - in_sig[0]: SF bytes input sequence\
      \ (4+CR useful bits per byte)\nOUTPUT:\n    - out_sig[0]: CR int32 output sequence\n\
      \"\"\"\n\nimport numpy as np\nfrom gnuradio import gr\nimport time \n\nclass\
      \ Interleaver(gr.basic_block):\n    def __init__(self, SF=9, CR=4):\n      \
      \  gr.basic_block.__init__(self,\n            name=\"LoRa Interleaver\",\n \
      \           in_sig=[np.uint8],\n            out_sig=[np.uint32])\n        self.SF\
      \ = SF\n        self.CR = CR\n\n    def forecast(self, noutput_items, ninputs)\
      \ :\n        #ninput_items_required[i] is the number of items that will be consumed\
      \ on input port i\n        ninput_items_required = [self.SF]*ninputs   # we\
      \ need SF items to produce anything\n        return ninput_items_required\n\n\
      \    def general_work(self, input_items, output_items):\n        \n        if(len(input_items[0])\
      \ >= self.SF) :    # if we have enough items to process\n            in0 = input_items[0][:self.SF]\
      \  # input buffer reference\n            # formatting the input buffer\n   \
      \         input_matrix = np.zeros((self.SF, self.CR+4), dtype=np.uint8)\n  \
      \          for i in range(len(in0)):\n                bits_crop = [int(x) for\
      \ x in bin(in0[i])[2:]]                                       # convert to binary\
      \  \n                input_matrix[i][:] = ([0]*(self.CR+4-len(bits_crop)) +\
      \ bits_crop)[-(self.CR+4):]    # crop to 4+CR bits\n\n            # interleaving\n\
      \            output_matrix = np.zeros((self.CR+4, self.SF), dtype=np.uint8)\n\
      \            for i in range(0,(self.CR+4)) :\n                for j in range(0,(self.SF))\
      \ :\n                    idi=self.SF-1-(j-i)%self.SF\n                    idj=self.CR+4-1-i\n\
      \                    output_matrix[i][j]=input_matrix[idi][idj]\n          \
      \  \n            # to uint32\n            output_items[0][0:(self.CR+4)] = output_matrix.dot(1\
      \ << np.arange(output_matrix.shape[-1] - 1, -1, -1))\n            # # debug\n\
      \            # print(\"\\n--- GENERAL WORK : INTERLEAVER ---\")\n          \
      \  # print(\"in0 :\")\n            # print(in0)\n            # print(\"len(in0)\
      \ (should be SF): \")\n            # print(len(in0))\n            # print(\"\
      input_matrix (SF x CR+4):\")\n            # print(input_matrix)\n          \
      \  # print(\"output_matrix (CR+4 x SF):\")\n            # print(output_matrix)\n\
      \            # print(\"output_items[0] = \")\n            # print(output_items[0])\n\
      \n            self.consume(0, self.SF)    # consume inputs (should be SF)\n\
      \            return self.CR+4            # return produced outputs (should be\
      \ CR+4)\n\n        else :\n            return 0\n\n\n\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('LoRa Interleaver', 'Interleaver', [('SF', '9'), ('CR', '4')], [('0',
      'byte', 1)], [('0', 'int', 1)], '', ['CR', 'SF'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [664, 476.0]
    rotation: 0
    state: enabled
- name: epy_block_1_0_0
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nWhitening block\nWhiten input sequence to remove the frequency\
      \ and time correlations in it.\n\nINPUT:\n    - in_sig[0]: binary input sequence\
      \ (4 useful bits per byte)\nOUTPUT:\n    - out_sig[0]: whitened binary sequence\n\
      \"\"\"\n\nimport numpy as np\nfrom gnuradio import gr\nimport time\n\nwhitening_seq\
      \ =(0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE1, 0xC2, 0x85, 0x0B, 0x17, 0x2F, 0x5E,\
      \ 0xBC, 0x78, 0xF1, 0xE3,\n                0xC6, 0x8D, 0x1A, 0x34, 0x68, 0xD0,\
      \ 0xA0, 0x40, 0x80, 0x01, 0x02, 0x04, 0x08, 0x11, 0x23, 0x47,\n            \
      \    0x8E, 0x1C, 0x38, 0x71, 0xE2, 0xC4, 0x89, 0x12, 0x25, 0x4B, 0x97, 0x2E,\
      \ 0x5C, 0xB8, 0x70, 0xE0,\n                0xC0, 0x81, 0x03, 0x06, 0x0C, 0x19,\
      \ 0x32, 0x64, 0xC9, 0x92, 0x24, 0x49, 0x93, 0x26, 0x4D, 0x9B,\n            \
      \    0x37, 0x6E, 0xDC, 0xB9, 0x72, 0xE4, 0xC8, 0x90, 0x20, 0x41, 0x82, 0x05,\
      \ 0x0A, 0x15, 0x2B, 0x56,\n                0xAD, 0x5B, 0xB6, 0x6D, 0xDA, 0xB5,\
      \ 0x6B, 0xD6, 0xAC, 0x59, 0xB2, 0x65, 0xCB, 0x96, 0x2C, 0x58,\n            \
      \    0xB0, 0x61, 0xC3, 0x87, 0x0F, 0x1F, 0x3E, 0x7D, 0xFB, 0xF6, 0xED, 0xDB,\
      \ 0xB7, 0x6F, 0xDE, 0xBD,\n                0x7A, 0xF5, 0xEB, 0xD7, 0xAE, 0x5D,\
      \ 0xBA, 0x74, 0xE8, 0xD1, 0xA2, 0x44, 0x88, 0x10, 0x21, 0x43,\n            \
      \    0x86, 0x0D, 0x1B, 0x36, 0x6C, 0xD8, 0xB1, 0x63, 0xC7, 0x8F, 0x1E, 0x3C,\
      \ 0x79, 0xF3, 0xE7, 0xCE,\n                0x9C, 0x39, 0x73, 0xE6, 0xCC, 0x98,\
      \ 0x31, 0x62, 0xC5, 0x8B, 0x16, 0x2D, 0x5A, 0xB4, 0x69, 0xD2,\n            \
      \    0xA4, 0x48, 0x91, 0x22, 0x45, 0x8A, 0x14, 0x29, 0x52, 0xA5, 0x4A, 0x95,\
      \ 0x2A, 0x54, 0xA9, 0x53,\n                0xA7, 0x4E, 0x9D, 0x3B, 0x77, 0xEE,\
      \ 0xDD, 0xBB, 0x76, 0xEC, 0xD9, 0xB3, 0x67, 0xCF, 0x9E, 0x3D,\n            \
      \    0x7B, 0xF7, 0xEF, 0xDF, 0xBF, 0x7E, 0xFD, 0xFA, 0xF4, 0xE9, 0xD3, 0xA6,\
      \ 0x4C, 0x99, 0x33, 0x66,\n                0xCD, 0x9A, 0x35, 0x6A, 0xD4, 0xA8,\
      \ 0x51, 0xA3, 0x46, 0x8C, 0x18, 0x30, 0x60, 0xC1, 0x83, 0x07,\n            \
      \    0x0E, 0x1D, 0x3A, 0x75, 0xEA, 0xD5, 0xAA, 0x55, 0xAB, 0x57, 0xAF, 0x5F,\
      \ 0xBE, 0x7C, 0xF9, 0xF2,\n                0xE5, 0xCA, 0x94, 0x28, 0x50, 0xA1,\
      \ 0x42, 0x84, 0x09, 0x13, 0x27, 0x4F, 0x9F, 0x3F, 0x7F)\n\nclass Whitening(gr.sync_block):\n\
      \    def __init__(self):\n        gr.sync_block.__init__(\n            self,\n\
      \            name='LoRa Whitening',\n            in_sig=[np.uint8],\n      \
      \      out_sig=[np.uint8]\n        )\n        self.table_idx = 0 # index of\
      \ the whitening table cell to be used for whitening\n        \n    def work(self,\
      \ input_items, output_items):\n        \n        in0 = input_items[0]    # input\
      \ buffer reference\n        out = output_items[0]   # output buffer reference\n\
      \n        input_matrix = np.zeros((len(in0), 4), dtype=np.uint8)\n        for\
      \ i in range(len(in0)):\n            bits_crop = [int(x) for x in bin(in0[i])[2:]]\
      \                       # convert to binary\n            input_matrix[i][:]\
      \ = ([0]*(4-len(bits_crop)) + bits_crop)[-(4):]    # crop to 4 useful bits\n\
      \            out[i] = in0[i] ^ whitening_seq[self.table_idx] # whiten (XOR)\
      \ the input vector\n            self.table_idx += 1                        \
      \ # increment table index\n            if(self.table_idx == len(whitening_seq)):\
      \   # if table index is out of bounds, reset it\n                self.table_idx\
      \ = 0\n   \n\n\n        # # debug\n        # print(\"\\n--- GENERAL WORK : WHITENING\
      \ ---\")\n        # print(\"in0 :\")\n        # print(in0)\n        # print(\"\
      input_matrix :\")\n        # print(input_matrix)\n        # print(\"out :\"\
      )\n        # print(out)\n        # print(\"return len(out): \")\n        # print(len(out))\n\
      \        # print(\"--- WHITENING END---\")\n\n        return len(out)\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('LoRa Whitening', 'Whitening', [], [('0', 'byte', 1)], [('0', 'byte',
      1)], '', [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [280, 488.0]
    rotation: 0
    state: enabled
- name: epy_block_1_1
  id: epy_block
  parameters:
    CR: CR
    _source_code: "\"\"\"\nHamming encoding block\nForward Error Correction encoding\
      \ block.\nReference : \"MIT EECS II : http://web.mit.edu/6.02/www/f2012/handouts/L05_slides.pdf\"\
      \n\nINPUT:\n    - in_sig[0]: binary input sequence (4 useful bits per byte)\n\
      OUTPUT:\n    - out_sig[0]: binary output sequence (4+CR useful bits per byte)\n\
      \"\"\"\n\nimport numpy as np\nfrom gnuradio import gr\n\n\nclass HammingTx(gr.sync_block):\n\
      \    def __init__(self, CR = 4):\n        gr.sync_block.__init__(\n        \
      \    self,\n            name='LoRa Hamming Tx',\n            in_sig=[np.uint8],\n\
      \            out_sig=[np.uint8]\n        )\n        self.CR = CR\n\n    def\
      \ work(self, input_items, output_items):\n        \n        in0 = input_items[0]\
      \    # input buffer reference\n        out = output_items[0]   # output buffer\
      \ reference\n    \n        output_matrix = np.zeros((len(in0), 4+self.CR), dtype=np.uint8)\n\
      \        input_matrix = np.zeros((len(in0), 4), dtype=np.uint8)\n\n        #\
      \ Hamming encoding (iterate over matrix lines and encode each)\n        for\
      \ i in range(len(in0)):\n            bits_crop = [int(x) for x in bin(in0[i])[2:]]\
      \                       # convert to binary    \n            input_matrix[i][:]\
      \ = ([0]*(4-len(bits_crop)) + bits_crop)[-(4):]    # crop to 4 bits\n\n    \
      \        if self.CR == 1: # CR = 1, add one parity bit\n                p0 =\
      \ input_matrix[i][0] ^ input_matrix[i][1] ^ input_matrix[i][2] ^ input_matrix[i][3]\n\
      \                output_matrix[i] = np.asarray([input_matrix[i][0], input_matrix[i][1],\
      \ input_matrix[i][2], input_matrix[i][3], p0], dtype=np.uint8)\n\n         \
      \   if self.CR == 2: # CR = 2, add two parity bits\n                p0 = input_matrix[i][0]\
      \ ^ input_matrix[i][1] ^ input_matrix[i][2]\n                p1 = input_matrix[i][1]\
      \ ^ input_matrix[i][2] ^ input_matrix[i][3]\n                output_matrix[i]\
      \ = np.asarray([input_matrix[i][0], input_matrix[i][1], input_matrix[i][2],\
      \ input_matrix[i][3], p1, p0], dtype=np.uint8)\n\n            if self.CR ==\
      \ 3: # CR = 3, add three parity bits (Hamming(7,4))\n                Q = np.array([[0,1,1,1],\
      \ [1,1,0,1], [1,1,1,0], [1,0,1,1]], np.uint8) \n                Id = np.identity(4,\
      \ dtype=np.uint8)\n                G = np.concatenate((Id, Q),axis=1)  # generator\
      \ matrix\n                output_matrix[i] = (np.dot(input_matrix[i],G)%2)[0:4+self.CR]\n\
      \n            if self.CR == 4: # CR = 4, add four parity bits (Hamming(8,4))\n\
      \                Q = np.array([[0,1,1,1], [1,1,0,1], [1,1,1,0], [1,0,1,1]],\
      \ np.uint8)\n                Id = np.identity(4, dtype=np.uint8)\n         \
      \       G = np.concatenate((Id, Q),axis=1)  # generator matrix\n           \
      \     output_matrix[i] = (np.dot(input_matrix[i],G)%2)\n\n        # binary to\
      \ decimal conversion\n        out[:] = output_matrix.dot(1 << np.arange(output_matrix.shape[-1]\
      \ - 1, -1, -1))\n\n        # #debug\n        # print(\"\\n--- GENERAL WORK :\
      \ HAMMING_ENC ---\")\n        # print(\"in0 :\")\n        # print(in0)\n   \
      \     # print(\"input_matrix :\")\n        # print(input_matrix)\n        #\
      \ print(\"output_matrix :\")\n        # print(output_matrix)\n        # print(\"\
      out :\")\n        # print(out)\n        # print(\"--- HAMMING_ENC END---\")\n\
      \n        return len(output_items[0])\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('LoRa Hamming Tx', 'HammingTx', [('CR', '4')], [('0', 'byte', 1)],
      [('0', 'byte', 1)], '', ['CR'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [472, 484.0]
    rotation: 0
    state: enabled
- name: epy_block_6_0_0_0_0_0
  id: epy_block
  parameters:
    SF: SF
    _source_code: "\"\"\"\nModulation Block:\nReference : \"Towards an SDR implementation\
      \ of LoRa...\" 2020 A.Marquet, N.Montavont, G.Papadopoulos)\n\nINPUT:\n    -\
      \ in_sig[0]: int32 input stream\nOUTPUT:\n    - out_sig[0]: IQ complex vectors\
      \ output stream\n\"\"\"\n\nimport numpy as np\nfrom gnuradio import gr\nimport\
      \ math\nimport time\n\n# def modulate(SF, id, os_factor, sign) :\n#     M  =\
      \ pow(2,SF)\n#     n_fold = M * os_factor - id * os_factor\n#     chirp = np.zeros(M*os_factor,\
      \ dtype=np.complex64)\n#     for n in range(0,M*os_factor):\n#         if n\
      \ < n_fold:\n#             chirp[n] = np.exp(2j*math.pi *(n*n/(2*M)/pow(os_factor,2)+(id/M-0.5)*n/os_factor))\n\
      #         else:\n#             chirp[n] = np.exp(2j*math.pi *(n*n/(2*M)/pow(os_factor,2)+(id/M-1.5)*n/os_factor))\n\
      #     return chirp\n\ndef modulate(SF, id, os_factor, sign) :\n    M  = pow(2,SF)\n\
      \    ka = np.arange(0,M)\n    fact1 = np.exp(1j*sign*math.pi*(pow(ka,2))/M)\n\
      \    chirp = fact1*np.exp(2j*math.pi*(id/M)*ka)\n\n    return chirp\n\nclass\
      \ Modulation(gr.sync_block):\n    def __init__(self, SF = 9):\n        gr.sync_block.__init__(\n\
      \            self,\n            name='LoRa Modulation',\n            in_sig=[np.uint32],\n\
      \            out_sig=[(np.complex64,pow(2,SF))]\n        )\n        self.SF\
      \ = SF\n\n    def work(self, input_items, output_items):\n\n        symbols\
      \ = input_items[0]\n        for i in range (len(symbols)) :\n            # t\
      \ = time.time()\n            output_items[0][i] = modulate(self.SF, symbols[i],\
      \ 1, 1)   # modulate every symbol\n            # elapsed = time.time() - t\n\
      \            # print(\"Modulation time: \", elapsed)\n\n        # # debug\n\
      \        # print(\"\\n--- GENERAL WORK : MODULATION ---\")\n        # print(\"\
      symbols :\")\n        # print(symbols)\n\n        return len(output_items[0])"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('LoRa Modulation', 'Modulation', [('SF', '9')], [('0', 'int', 1)],
      [('0', 'complex', 512)], '', ['SF'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [848, 484.0]
    rotation: 0
    state: enabled
- name: pdu_pdu_to_stream_x_0
  id: pdu_pdu_to_stream_x
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    depth: '64'
    early_behavior: pdu.EARLY_BURST_APPEND
    maxoutbuf: '0'
    minoutbuf: '0'
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [608, 244.0]
    rotation: 0
    state: enabled
- name: pdu_random_pdu_0
  id: pdu_random_pdu
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    length_modulo: SF
    mask: '0x0F'
    maxoutbuf: '0'
    maxsize: SF*10
    minoutbuf: '0'
    minsize: SF*10
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [352, 220.0]
    rotation: 0
    state: enabled
- name: uhd_usrp_sink_0_0
  id: uhd_usrp_sink
  parameters:
    affinity: ''
    alias: ''
    ant0: TX/RX
    ant1: TX/RX
    ant10: TX/RX
    ant11: TX/RX
    ant12: TX/RX
    ant13: TX/RX
    ant14: TX/RX
    ant15: TX/RX
    ant16: TX/RX
    ant17: TX/RX
    ant18: TX/RX
    ant19: TX/RX
    ant2: TX/RX
    ant20: TX/RX
    ant21: TX/RX
    ant22: TX/RX
    ant23: TX/RX
    ant24: TX/RX
    ant25: TX/RX
    ant26: TX/RX
    ant27: TX/RX
    ant28: TX/RX
    ant29: TX/RX
    ant3: TX/RX
    ant30: TX/RX
    ant31: TX/RX
    ant4: TX/RX
    ant5: TX/RX
    ant6: TX/RX
    ant7: TX/RX
    ant8: TX/RX
    ant9: TX/RX
    bw0: samp_rate
    bw1: '0'
    bw10: '0'
    bw11: '0'
    bw12: '0'
    bw13: '0'
    bw14: '0'
    bw15: '0'
    bw16: '0'
    bw17: '0'
    bw18: '0'
    bw19: '0'
    bw2: '0'
    bw20: '0'
    bw21: '0'
    bw22: '0'
    bw23: '0'
    bw24: '0'
    bw25: '0'
    bw26: '0'
    bw27: '0'
    bw28: '0'
    bw29: '0'
    bw3: '0'
    bw30: '0'
    bw31: '0'
    bw4: '0'
    bw5: '0'
    bw6: '0'
    bw7: '0'
    bw8: '0'
    bw9: '0'
    center_freq0: center_freq
    center_freq1: '0'
    center_freq10: '0'
    center_freq11: '0'
    center_freq12: '0'
    center_freq13: '0'
    center_freq14: '0'
    center_freq15: '0'
    center_freq16: '0'
    center_freq17: '0'
    center_freq18: '0'
    center_freq19: '0'
    center_freq2: '0'
    center_freq20: '0'
    center_freq21: '0'
    center_freq22: '0'
    center_freq23: '0'
    center_freq24: '0'
    center_freq25: '0'
    center_freq26: '0'
    center_freq27: '0'
    center_freq28: '0'
    center_freq29: '0'
    center_freq3: '0'
    center_freq30: '0'
    center_freq31: '0'
    center_freq4: '0'
    center_freq5: '0'
    center_freq6: '0'
    center_freq7: '0'
    center_freq8: '0'
    center_freq9: '0'
    clock_rate: 0e0
    clock_source0: ''
    clock_source1: ''
    clock_source2: ''
    clock_source3: ''
    clock_source4: ''
    clock_source5: ''
    clock_source6: ''
    clock_source7: ''
    comment: ''
    dev_addr: '"addr=192.168.10.2"'
    dev_args: '""'
    gain0: '0'
    gain1: '0'
    gain10: '0'
    gain11: '0'
    gain12: '0'
    gain13: '0'
    gain14: '0'
    gain15: '0'
    gain16: '0'
    gain17: '0'
    gain18: '0'
    gain19: '0'
    gain2: '0'
    gain20: '0'
    gain21: '0'
    gain22: '0'
    gain23: '0'
    gain24: '0'
    gain25: '0'
    gain26: '0'
    gain27: '0'
    gain28: '0'
    gain29: '0'
    gain3: '0'
    gain30: '0'
    gain31: '0'
    gain4: '0'
    gain5: '0'
    gain6: '0'
    gain7: '0'
    gain8: '0'
    gain9: '0'
    gain_type0: default
    gain_type1: default
    gain_type10: default
    gain_type11: default
    gain_type12: default
    gain_type13: default
    gain_type14: default
    gain_type15: default
    gain_type16: default
    gain_type17: default
    gain_type18: default
    gain_type19: default
    gain_type2: default
    gain_type20: default
    gain_type21: default
    gain_type22: default
    gain_type23: default
    gain_type24: default
    gain_type25: default
    gain_type26: default
    gain_type27: default
    gain_type28: default
    gain_type29: default
    gain_type3: default
    gain_type30: default
    gain_type31: default
    gain_type4: default
    gain_type5: default
    gain_type6: default
    gain_type7: default
    gain_type8: default
    gain_type9: default
    len_tag_name: ''
    lo_export0: 'False'
    lo_export1: 'False'
    lo_export10: 'False'
    lo_export11: 'False'
    lo_export12: 'False'
    lo_export13: 'False'
    lo_export14: 'False'
    lo_export15: 'False'
    lo_export16: 'False'
    lo_export17: 'False'
    lo_export18: 'False'
    lo_export19: 'False'
    lo_export2: 'False'
    lo_export20: 'False'
    lo_export21: 'False'
    lo_export22: 'False'
    lo_export23: 'False'
    lo_export24: 'False'
    lo_export25: 'False'
    lo_export26: 'False'
    lo_export27: 'False'
    lo_export28: 'False'
    lo_export29: 'False'
    lo_export3: 'False'
    lo_export30: 'False'
    lo_export31: 'False'
    lo_export4: 'False'
    lo_export5: 'False'
    lo_export6: 'False'
    lo_export7: 'False'
    lo_export8: 'False'
    lo_export9: 'False'
    lo_source0: internal
    lo_source1: internal
    lo_source10: internal
    lo_source11: internal
    lo_source12: internal
    lo_source13: internal
    lo_source14: internal
    lo_source15: internal
    lo_source16: internal
    lo_source17: internal
    lo_source18: internal
    lo_source19: internal
    lo_source2: internal
    lo_source20: internal
    lo_source21: internal
    lo_source22: internal
    lo_source23: internal
    lo_source24: internal
    lo_source25: internal
    lo_source26: internal
    lo_source27: internal
    lo_source28: internal
    lo_source29: internal
    lo_source3: internal
    lo_source30: internal
    lo_source31: internal
    lo_source4: internal
    lo_source5: internal
    lo_source6: internal
    lo_source7: internal
    lo_source8: internal
    lo_source9: internal
    maxoutbuf: '0'
    minoutbuf: '0'
    nchan: '1'
    num_mboards: '1'
    otw: ''
    samp_rate: samp_rate
    sd_spec0: ''
    sd_spec1: ''
    sd_spec2: ''
    sd_spec3: ''
    sd_spec4: ''
    sd_spec5: ''
    sd_spec6: ''
    sd_spec7: ''
    show_lo_controls: 'False'
    start_time: '-1.0'
    stream_args: ''
    stream_chans: '[]'
    sync: pc_clock
    time_source0: ''
    time_source1: ''
    time_source2: ''
    time_source3: ''
    time_source4: ''
    time_source5: ''
    time_source6: ''
    time_source7: ''
    type: fc32
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1264, 420.0]
    rotation: 0
    state: enabled
- name: virtual_sink_0
  id: virtual_sink
  parameters:
    alias: ''
    comment: ''
    stream_id: input
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [816, 244.0]
    rotation: 0
    state: enabled
- name: virtual_source_0
  id: virtual_source
  parameters:
    alias: ''
    comment: ''
    stream_id: input
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [72, 484.0]
    rotation: 0
    state: enabled

connections:
- [blocks_message_strobe_0, strobe, pdu_random_pdu_0, generate]
- [blocks_vector_to_stream_0_0_1, '0', uhd_usrp_sink_0_0, '0']
- [epy_block_0_1_0_0, '0', epy_block_6_0_0_0_0_0, '0']
- [epy_block_1_0_0, '0', epy_block_1_1, '0']
- [epy_block_1_1, '0', epy_block_0_1_0_0, '0']
- [epy_block_6_0_0_0_0_0, '0', blocks_vector_to_stream_0_0_1, '0']
- [pdu_pdu_to_stream_x_0, '0', virtual_sink_0, '0']
- [pdu_random_pdu_0, pdus, pdu_pdu_to_stream_x_0, pdus]
- [virtual_source_0, '0', blocks_file_sink_0_3, '0']
- [virtual_source_0, '0', epy_block_1_0_0, '0']

metadata:
  file_format: 1
  grc_version: 3.10.2.0
