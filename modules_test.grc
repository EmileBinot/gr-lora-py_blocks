options:
  parameters:
    author: ''
    catch_exceptions: 'True'
    category: '[GRC Hier Blocks]'
    cmake_opt: ''
    comment: ''
    copyright: ''
    description: ''
    gen_cmake: 'On'
    gen_linking: dynamic
    generate_options: no_gui
    hier_block_src_path: '.:'
    id: modules_test
    max_nouts: '0'
    output_language: python
    placement: (0,0)
    qt_qss_theme: ''
    realtime_scheduling: ''
    run: 'True'
    run_command: '{python} -u {filename}'
    run_options: prompt
    sizing_mode: fixed
    thread_safe_setters: ''
    title: Not titled yet
    window_size: (1000,1000)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [96, 28.0]
    rotation: 0
    state: enabled

blocks:
- name: samp_rate
  id: variable
  parameters:
    comment: ''
    value: '32000'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [504, 28.0]
    rotation: 0
    state: enabled
- name: blocks_null_sink_0
  id: blocks_null_sink
  parameters:
    affinity: ''
    alias: ''
    bus_structure_sink: '[[0,],]'
    comment: ''
    num_inputs: '1'
    type: int
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [592, 176.0]
    rotation: 0
    state: enabled
- name: blocks_null_sink_0_0
  id: blocks_null_sink
  parameters:
    affinity: ''
    alias: ''
    bus_structure_sink: '[[0,],]'
    comment: ''
    num_inputs: '1'
    type: byte
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [584, 272.0]
    rotation: 0
    state: enabled
- name: blocks_null_sink_0_0_0
  id: blocks_null_sink
  parameters:
    affinity: ''
    alias: ''
    bus_structure_sink: '[[0,],]'
    comment: ''
    num_inputs: '1'
    type: byte
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [520, 376.0]
    rotation: 0
    state: enabled
- name: blocks_vector_source_x_0
  id: blocks_vector_source_x
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    repeat: 'False'
    tags: '[]'
    type: byte
    vector: (0xFF, 0x7F, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x01, 0x00)
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [128, 156.0]
    rotation: 0
    state: enabled
- name: blocks_vector_source_x_0_0
  id: blocks_vector_source_x
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    repeat: 'False'
    tags: '[]'
    type: byte
    vector: (0xFF, 0x7F, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x01, 0x00)
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [128, 252.0]
    rotation: 0
    state: enabled
- name: blocks_vector_source_x_0_0_0
  id: blocks_vector_source_x
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    repeat: 'False'
    tags: '[]'
    type: byte
    vector: (0x00, 0x00, 0x00)
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [128, 356.0]
    rotation: 0
    state: enabled
- name: epy_block_0
  id: epy_block
  parameters:
    CR: '2'
    SF: '9'
    _source_code: "\"\"\"\nInterleaving block\nScrambles bits together to fight error\
      \ bursts.\nReference : \"Towards an SDR implementation of LoRa...\" 2020 A.Marquet,\
      \ N.Montavont, G.Papadopoulos)\n\"\"\"\n\nimport numpy as np\nfrom gnuradio\
      \ import gr\n\nclass Interleaver(gr.basic_block):\n    def __init__(self, SF=5,\
      \ CR=4):\n        gr.basic_block.__init__(self,\n            name=\"Interleaver\"\
      ,\n            in_sig=[np.uint8],\n            out_sig=[np.uint32])\n      \
      \  self.SF = SF\n        self.CR = CR\n\n    def general_work(self, input_items,\
      \ output_items):\n\n        #buffer references\n        in0 = input_items[0][:self.SF]\n\
      \        out = output_items[0]\n\n        # parsing in0 (convert + crop to lines\
      \ of CR+4 bits and bundle in matrix)\n        input_matrix = np.zeros((self.SF,\
      \ self.CR+4), dtype=np.uint8)\n        for i in range(len(in0)):\n         \
      \   bits_crop = [int(x) for x in bin(in0[i])[2:]]        \n            bits_crop_norm\
      \ = ([0]*(self.CR+4-len(bits_crop)) + bits_crop)[-(self.CR+4):]\n          \
      \  input_matrix[i][:] = np.asarray(bits_crop_norm, dtype=np.uint8)\n\n     \
      \   # interleaving\n        output_matrix = np.zeros((self.CR+4, self.SF), dtype=np.uint8)\n\
      \        for i in range(0,(self.CR+4)-1) :\n            for j in range(0,(self.SF)-1)\
      \ :\n                idi=self.SF-1-(j-i)%self.SF\n                idj=self.CR+4-1-i\n\
      \                output_matrix[i][j]=input_matrix[idi][idj]\n\n        out =\
      \ output_matrix.dot(1 << np.arange(output_matrix.shape[-1] - 1, -1, -1))\n\n\
      \        # debug\n        # print(\"\\n--- GENERAL WORK : INTERLEAVER ---\"\
      )\n        # print(\"in0 :\")\n        # print(in0)\n        # print(\"len(in0)\
      \ (should be SF): \")\n        # print(len(in0))\n        # print(\"input_matrix\
      \ (SF x CR+4):\")\n        # print(input_matrix)\n        # print(\"output_matrix\
      \ (CR+4 x SF):\")\n        # print(output_matrix)\n        # print(\"out = \"\
      )\n        # print(out)\n        # print(\"return len(out) (should be CR+4):\
      \ \")\n        # print(len(out))\n\n        #consume the inputs (should be SF)\n\
      \        self.consume(0, len(in0))\n\n        #return produced items (should\
      \ be CR+4)\n        return len(out)\n\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('Interleaver', 'Interleaver', [('SF', '5'), ('CR', '4')], [('0', 'byte',
      1)], [('0', 'int', 1)], '', ['CR', 'SF'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [400, 164.0]
    rotation: 0
    state: enabled
- name: epy_block_1
  id: epy_block
  parameters:
    CR: '4'
    _source_code: "\"\"\"\nHamming encoding block\nForward Error Correction encoding\
      \ block\nReference : \"Towards an SDR implementation of LoRa...\" 2020 A.Marquet,\
      \ N.Montavont, G.Papadopoulos)\n\"\"\"\n\nfrom nis import match\nfrom unittest\
      \ import case\nimport numpy as np\nfrom gnuradio import gr\n\n\nclass Hamming_enc(gr.sync_block):\
      \  # other base classes are basic_block, decim_block, interp_block\n    def\
      \ __init__(self, CR = 4):  # only default arguments here\n        gr.sync_block.__init__(\n\
      \            self,\n            name='Hamming_enc',   # will show up in GRC\n\
      \            in_sig=[np.uint8],\n            out_sig=[np.uint8]\n        )\n\
      \        self.CR = CR\n\n    def work(self, input_items, output_items):\n  \
      \      \n        in0 = input_items[0]\n        out = output_items[0]\n    \n\
      \        # Hamming encoding (iterate over matrix lines and encode each)\n  \
      \      output_matrix = np.zeros((len(in0), 4+self.CR), dtype=np.uint8)\n   \
      \     input_matrix = np.zeros((len(in0), 4), dtype=np.uint8)\n        for i\
      \ in range(len(in0)):\n\n            # parsing in0 (convert + crop to lines\
      \ of 4 bits and bundle in matrix)\n            bits_crop = [int(x) for x in\
      \ bin(in0[i])[2:]]        \n            bits_crop_norm = ([0]*(4-len(bits_crop))\
      \ + bits_crop)[-(4):]\n            input_matrix[i][:] = np.asarray(bits_crop_norm,\
      \ dtype=np.uint8)\n\n            if self.CR == 1:\n                p0 = input_matrix[i][0]\
      \ ^ input_matrix[i][1] ^ input_matrix[i][2] ^ input_matrix[i][3]\n         \
      \       output_matrix[i] = np.asarray([input_matrix[i][0], input_matrix[i][1],\
      \ input_matrix[i][2], input_matrix[i][3], p0], dtype=np.uint8)\n\n         \
      \   if self.CR == 2:\n                p0 = input_matrix[i][0] ^ input_matrix[i][1]\
      \ ^ input_matrix[i][2]\n                p1 = input_matrix[i][1] ^ input_matrix[i][2]\
      \ ^ input_matrix[i][3]\n                output_matrix[i] = np.asarray([input_matrix[i][0],\
      \ input_matrix[i][1], input_matrix[i][2], input_matrix[i][3], p1, p0], dtype=np.uint8)\n\
      \n            if self.CR == 3:\n                Q = np.array([[0,1,1,1], [1,1,0,1],\
      \ [1,1,1,0], [1,0,1,1]], np.uint8)\n                Id = np.identity(4, dtype=np.uint8)\n\
      \                G = np.concatenate((Id, Q),axis=1)\n                output_matrix[i]\
      \ = (np.dot(input_matrix[i],G)%2)[0:4+self.CR]\n\n            if self.CR ==\
      \ 4:\n                Q = np.array([[0,1,1,1], [1,1,0,1], [1,1,1,0], [1,0,1,1]],\
      \ np.uint8)\n                Id = np.identity(4, dtype=np.uint8)\n         \
      \       G = np.concatenate((Id, Q),axis=1)\n                output_matrix[i]\
      \ = (np.dot(input_matrix[i],G)%2)\n\n        #debug\n        # print(\"\\n---\
      \ GENERAL WORK : HAMMING_ENC ---\")\n        # print(\"in0 :\")\n        # print(in0)\n\
      \        # print(\"input_matrix :\")\n        # print(input_matrix)\n      \
      \  # print(\"output_matrix :\")\n        # print(output_matrix)\n\n        return\
      \ len(output_items[0])\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('Hamming_enc', 'Hamming_enc', [('CR', '4')], [('0', 'byte', 1)], [('0',
      'byte', 1)], '', ['CR'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [368, 268.0]
    rotation: 0
    state: enabled
- name: epy_block_1_0
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nWhitening block\nWhiten input sequence to remove the frequency\
      \ and time correlations in it.\n\n\"\"\"\nimport numpy as np\nfrom gnuradio\
      \ import gr\n\nwhitening_seq =(0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE1, 0xC2, 0x85,\
      \ 0x0B, 0x17, 0x2F, 0x5E, 0xBC, 0x78, 0xF1, 0xE3,\n                0xC6, 0x8D,\
      \ 0x1A, 0x34, 0x68, 0xD0, 0xA0, 0x40, 0x80, 0x01, 0x02, 0x04, 0x08, 0x11, 0x23,\
      \ 0x47,\n                0x8E, 0x1C, 0x38, 0x71, 0xE2, 0xC4, 0x89, 0x12, 0x25,\
      \ 0x4B, 0x97, 0x2E, 0x5C, 0xB8, 0x70, 0xE0,\n                0xC0, 0x81, 0x03,\
      \ 0x06, 0x0C, 0x19, 0x32, 0x64, 0xC9, 0x92, 0x24, 0x49, 0x93, 0x26, 0x4D, 0x9B,\n\
      \                0x37, 0x6E, 0xDC, 0xB9, 0x72, 0xE4, 0xC8, 0x90, 0x20, 0x41,\
      \ 0x82, 0x05, 0x0A, 0x15, 0x2B, 0x56,\n                0xAD, 0x5B, 0xB6, 0x6D,\
      \ 0xDA, 0xB5, 0x6B, 0xD6, 0xAC, 0x59, 0xB2, 0x65, 0xCB, 0x96, 0x2C, 0x58,\n\
      \                0xB0, 0x61, 0xC3, 0x87, 0x0F, 0x1F, 0x3E, 0x7D, 0xFB, 0xF6,\
      \ 0xED, 0xDB, 0xB7, 0x6F, 0xDE, 0xBD,\n                0x7A, 0xF5, 0xEB, 0xD7,\
      \ 0xAE, 0x5D, 0xBA, 0x74, 0xE8, 0xD1, 0xA2, 0x44, 0x88, 0x10, 0x21, 0x43,\n\
      \                0x86, 0x0D, 0x1B, 0x36, 0x6C, 0xD8, 0xB1, 0x63, 0xC7, 0x8F,\
      \ 0x1E, 0x3C, 0x79, 0xF3, 0xE7, 0xCE,\n                0x9C, 0x39, 0x73, 0xE6,\
      \ 0xCC, 0x98, 0x31, 0x62, 0xC5, 0x8B, 0x16, 0x2D, 0x5A, 0xB4, 0x69, 0xD2,\n\
      \                0xA4, 0x48, 0x91, 0x22, 0x45, 0x8A, 0x14, 0x29, 0x52, 0xA5,\
      \ 0x4A, 0x95, 0x2A, 0x54, 0xA9, 0x53,\n                0xA7, 0x4E, 0x9D, 0x3B,\
      \ 0x77, 0xEE, 0xDD, 0xBB, 0x76, 0xEC, 0xD9, 0xB3, 0x67, 0xCF, 0x9E, 0x3D,\n\
      \                0x7B, 0xF7, 0xEF, 0xDF, 0xBF, 0x7E, 0xFD, 0xFA, 0xF4, 0xE9,\
      \ 0xD3, 0xA6, 0x4C, 0x99, 0x33, 0x66,\n                0xCD, 0x9A, 0x35, 0x6A,\
      \ 0xD4, 0xA8, 0x51, 0xA3, 0x46, 0x8C, 0x18, 0x30, 0x60, 0xC1, 0x83, 0x07,\n\
      \                0x0E, 0x1D, 0x3A, 0x75, 0xEA, 0xD5, 0xAA, 0x55, 0xAB, 0x57,\
      \ 0xAF, 0x5F, 0xBE, 0x7C, 0xF9, 0xF2,\n                0xE5, 0xCA, 0x94, 0x28,\
      \ 0x50, 0xA1, 0x42, 0x84, 0x09, 0x13, 0x27, 0x4F, 0x9F, 0x3F, 0x7F)\n\n# whitening_seq_debug\
      \ =0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE1\n\nclass Whitening(gr.sync_block):  #\
      \ other base classes are basic_block, decim_block, interp_block\n    def __init__(self):\
      \  # only default arguments here\n        gr.sync_block.__init__(\n        \
      \    self,\n            name='Whitening',   # will show up in GRC\n        \
      \    in_sig=[np.uint8],\n            out_sig=[np.uint8]\n        )\n       \
      \ self.table_idx = 0\n        \n    def work(self, input_items, output_items):\n\
      \        \n        in0 = input_items[0]\n        out = output_items[0]\n   \
      \     # parsing in0 (convert + crop to lines of 4 bits and bundle in matrix)\n\
      \        input_matrix = np.zeros((len(in0), 4), dtype=np.uint8)\n        for\
      \ i in range(len(in0)):\n            bits_crop = [int(x) for x in bin(in0[i])[2:]]\
      \        \n            bits_crop_norm = ([0]*(4-len(bits_crop)) + bits_crop)[-(4):]\n\
      \            input_matrix[i][:] = np.asarray(bits_crop_norm, dtype=np.uint8)\n\
      \            \n            # whitening\n            out[i] = in0[i] ^ whitening_seq[self.table_idx]\n\
      \            self.table_idx += 1\n            if(self.table_idx == len(whitening_seq)):\n\
      \                self.table_idx = 0\n\n\n        #debug\n        # print(\"\\\
      n--- GENERAL WORK : WHITENING ---\")\n        # print(\"in0 :\")\n        #\
      \ print(in0)\n        # print(\"input_matrix :\")\n        # print(input_matrix)\n\
      \        # print(\"out :\")\n        # print(out)\n        # print(\"return\
      \ len(out): \")\n        # print(len(out))\n\n        return len(out)\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('Whitening', 'Whitening', [], [('0', 'byte', 1)], [('0', 'byte', 1)],
      '', [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [336, 376.0]
    rotation: 0
    state: enabled

connections:
- [blocks_vector_source_x_0, '0', epy_block_0, '0']
- [blocks_vector_source_x_0_0, '0', epy_block_1, '0']
- [blocks_vector_source_x_0_0_0, '0', epy_block_1_0, '0']
- [epy_block_0, '0', blocks_null_sink_0, '0']
- [epy_block_1, '0', blocks_null_sink_0_0, '0']
- [epy_block_1_0, '0', blocks_null_sink_0_0_0, '0']

metadata:
  file_format: 1
