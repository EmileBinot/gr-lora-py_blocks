options:
  parameters:
    author: ''
    catch_exceptions: 'True'
    category: '[GRC Hier Blocks]'
    cmake_opt: ''
    comment: ''
    copyright: ''
    description: ''
    gen_cmake: 'On'
    gen_linking: dynamic
    generate_options: qt_gui
    hier_block_src_path: '.:'
    id: modules_test
    max_nouts: '0'
    output_language: python
    placement: (0,0)
    qt_qss_theme: ''
    realtime_scheduling: ''
    run: 'True'
    run_command: '{python} -u {filename}'
    run_options: prompt
    sizing_mode: fixed
    thread_safe_setters: ''
    title: Not titled yet
    window_size: (1000,1000)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [40, 20.0]
    rotation: 0
    state: enabled

blocks:
- name: CR
  id: variable
  parameters:
    comment: ''
    value: '2'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [480, 36.0]
    rotation: 0
    state: enabled
- name: SF
  id: variable
  parameters:
    comment: ''
    value: '9'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [408, 36.0]
    rotation: 0
    state: enabled
- name: preamble_len
  id: variable
  parameters:
    comment: ''
    value: '4'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [208, 36.0]
    rotation: 0
    state: enabled
- name: samp_rate
  id: variable
  parameters:
    comment: ''
    value: '32000'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [312, 36.0]
    rotation: 0
    state: enabled
- name: blocks_file_sink_0
  id: blocks_file_sink
  parameters:
    affinity: ''
    alias: ''
    append: 'False'
    comment: ''
    file: dumpIN
    type: byte
    unbuffered: 'False'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [400, 228.0]
    rotation: 0
    state: disabled
- name: blocks_file_sink_0_0
  id: blocks_file_sink
  parameters:
    affinity: ''
    alias: ''
    append: 'False'
    comment: ''
    file: dump
    type: byte
    unbuffered: 'False'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1320, 92.0]
    rotation: 0
    state: disabled
- name: blocks_file_sink_0_1
  id: blocks_file_sink
  parameters:
    affinity: ''
    alias: ''
    append: 'False'
    comment: ''
    file: dumpOUT
    type: byte
    unbuffered: 'False'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1136, 628.0]
    rotation: 0
    state: disabled
- name: blocks_file_sink_1
  id: blocks_file_sink
  parameters:
    affinity: ''
    alias: ''
    append: 'False'
    comment: ''
    file: lora_frame
    type: complex
    unbuffered: 'False'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1368, 428.0]
    rotation: 0
    state: true
- name: blocks_stream_mux_0
  id: blocks_stream_mux
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    lengths: (round(pow(2,SF)*(preamble_len+2.25)), 9*512)
    maxoutbuf: '0'
    minoutbuf: '0'
    num_inputs: '2'
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1168, 392.0]
    rotation: 0
    state: true
- name: blocks_vector_source_x_0_0_0_0
  id: blocks_vector_source_x
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    repeat: 'False'
    tags: '[]'
    type: byte
    vector: (0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x01, 0x02, 0x03,
      0x04, 0x05, 0x06, 0x07, 0x08, 0x09)
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [88, 348.0]
    rotation: 0
    state: enabled
- name: blocks_vector_source_x_0_1
  id: blocks_vector_source_x
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    repeat: 'False'
    tags: '[]'
    type: byte
    vector: (0xFF, 0x7F, 0x3F, 0x1F, 0x1F, 0x1F)
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [944, 92.0]
    rotation: 0
    state: disabled
- name: blocks_vector_to_stream_0_0_0
  id: blocks_vector_to_stream
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    num_items: round(pow(2,SF)*(preamble_len+2.25))
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [984, 376.0]
    rotation: 0
    state: enabled
- name: blocks_vector_to_stream_0_0_1
  id: blocks_vector_to_stream
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    num_items: pow(2,SF)
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [976, 440.0]
    rotation: 0
    state: enabled
- name: epy_block_0
  id: epy_block
  parameters:
    CR: CR
    SF: SF
    _source_code: "\"\"\"\nInterleaving block\nScrambles bits together to fight error\
      \ bursts.\nReference : \"Towards an SDR implementation of LoRa...\" 2020 A.Marquet,\
      \ N.Montavont, G.Papadopoulos)\n\"\"\"\n\nimport numpy as np\nfrom gnuradio\
      \ import gr\n\nclass Deinterleaver(gr.basic_block):\n    def __init__(self,\
      \ SF=9, CR=2):\n        gr.basic_block.__init__(self,\n            name=\"LoRa\
      \ Deinterleaver\",\n            in_sig=[np.uint32],\n            out_sig=[np.uint8])\n\
      \        self.SF = SF\n        self.CR = CR\n\n    def forecast(self, noutput_items,\
      \ ninputs) :\n        ninput_items_required = [self.CR+4]*ninputs #ninput_items_required[i]\
      \ is the number of items that will be consumed on input port i\n        return\
      \ ninput_items_required\n\n    def general_work(self, input_items, output_items):\n\
      \        \n        if(len(input_items[0]) >= self.CR+4) :\n\n            #buffer\
      \ references\n            in0 = input_items[0][:self.CR+4]\n\n            #\
      \ parsing in0 (convert + crop to CR+4 lines of SF bits and bundle in matrix)\n\
      \            input_matrix = np.zeros((self.CR+4, self.SF), dtype=np.uint8)\n\
      \            for i in range(len(in0)):\n                bits_crop = [int(x)\
      \ for x in bin(in0[i])[2:]]        \n                bits_crop_norm = ([0]*(self.SF-len(bits_crop))\
      \ + bits_crop)[-(self.SF):]\n                input_matrix[i][:] = np.asarray(bits_crop_norm,\
      \ dtype=np.uint8)\n\n            # deinterleaving\n            output_matrix\
      \ = np.zeros((self.SF, self.CR+4), dtype=np.uint8)\n            for i in range(0,(self.SF))\
      \ :\n                for j in range(0,(self.CR+4)) :\n                    idi=self.CR+4-1-j\n\
      \                    idj=(self.SF-1-i+(self.CR+4)-1-j)%self.SF\n           \
      \         output_matrix[i][j]=input_matrix[idi][idj]\n\n\n            # to uint32\n\
      \            output_items[0][0:(self.SF)] = output_matrix.dot(1 << np.arange(output_matrix.shape[-1]\
      \ - 1, -1, -1))\n\n            # # debug\n            # print(\"\\n--- GENERAL\
      \ WORK : DEINTERLEAVER ---\")\n            # print(\"in0 :\")\n            #\
      \ print(in0)\n            # print(\"len(in0) (should be CR+4): \")\n       \
      \     # print(len(in0))\n            # print(\"input_matrix (CR+4 x SF):\")\n\
      \            # print(input_matrix)\n            # print(\"output_matrix (SF\
      \ x CR+4 ):\")\n            # print(output_matrix)\n            # print(\"output_items[0]\
      \ = \")\n            # print(output_items[0][0:(self.SF)])\n            # print(\"\
      return len(output_items[0]) (should be CR+4): \")\n            # print(len(output_items[0]))\n\
      \n            self.consume(0, self.CR+4)\n            # self.produce(0, self.SF-1)\n\
      \            return self.SF\n\n        else :\n            return 0"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('LoRa Deinterleaver', 'Deinterleaver', [('SF', '9'), ('CR', '2')],
      [('0', 'int', 1)], [('0', 'byte', 1)], '', ['CR', 'SF'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [584, 636.0]
    rotation: 0
    state: disabled
- name: epy_block_0_1_0_0
  id: epy_block
  parameters:
    CR: CR
    SF: SF
    _source_code: "\"\"\"\nInterleaving block\nScrambles bits together to fight error\
      \ bursts.\nReference : \"Towards an SDR implementation of LoRa...\" 2020 A.Marquet,\
      \ N.Montavont, G.Papadopoulos)\n\"\"\"\n\nimport numpy as np\nfrom gnuradio\
      \ import gr\n\nclass Interleaver(gr.basic_block):\n    def __init__(self, SF=9,\
      \ CR=4):\n        gr.basic_block.__init__(self,\n            name=\"LoRa Interleaver\"\
      ,\n            in_sig=[np.uint8],\n            out_sig=[np.uint32])\n      \
      \  self.SF = SF\n        self.CR = CR\n\n    def forecast(self, noutput_items,\
      \ ninputs) :\n        ninput_items_required = [self.SF]*ninputs #ninput_items_required[i]\
      \ is the number of items that will be consumed on input port i\n        return\
      \ ninput_items_required\n\n    def general_work(self, input_items, output_items):\n\
      \        \n        if(len(input_items[0]) >= self.SF) :\n\n            #buffer\
      \ references\n            in0 = input_items[0][:self.SF]\n\n            # parsing\
      \ in0 (convert + crop to SF lines of CR+4 bits and bundle in matrix)\n     \
      \       input_matrix = np.zeros((self.SF, self.CR+4), dtype=np.uint8)\n    \
      \        for i in range(len(in0)):\n                bits_crop = [int(x) for\
      \ x in bin(in0[i])[2:]]        \n                bits_crop_norm = ([0]*(self.CR+4-len(bits_crop))\
      \ + bits_crop)[-(self.CR+4):]\n                input_matrix[i][:] = np.asarray(bits_crop_norm,\
      \ dtype=np.uint8)\n\n            # interleaving\n            output_matrix =\
      \ np.zeros((self.CR+4, self.SF), dtype=np.uint8)\n            for i in range(0,(self.CR+4))\
      \ :\n                for j in range(0,(self.SF)) :\n                    idi=self.SF-1-(j-i)%self.SF\n\
      \                    idj=self.CR+4-1-i\n                    output_matrix[i][j]=input_matrix[idi][idj]\n\
      \            \n            # to uint32\n            output_items[0][0:(self.CR+4)]\
      \ = output_matrix.dot(1 << np.arange(output_matrix.shape[-1] - 1, -1, -1))\n\
      \n            # # debug\n            # print(\"\\n--- GENERAL WORK : INTERLEAVER\
      \ ---\")\n            # print(\"in0 :\")\n            # print(in0)\n       \
      \     # print(\"len(in0) (should be SF): \")\n            # print(len(in0))\n\
      \            # print(\"input_matrix (SF x CR+4):\")\n            # print(input_matrix)\n\
      \            # print(\"output_matrix (CR+4 x SF):\")\n            # print(output_matrix)\n\
      \            # print(\"output_items[0] = \")\n            # print(output_items[0])\n\
      \n            #consume inputs (should be SF)\n            self.consume(0, self.SF)\n\
      \            return self.CR+4\n\n        else :\n            return 0\n\n\n\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('LoRa Interleaver', 'Interleaver', [('SF', '9'), ('CR', '4')], [('0',
      'byte', 1)], [('0', 'int', 1)], '', ['CR', 'SF'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [648, 428.0]
    rotation: 0
    state: enabled
- name: epy_block_1
  id: epy_block
  parameters:
    CR: CR
    _source_code: "\"\"\"\nHamming Decoding block\nForward Error Correction encoding\
      \ block\nReference : \"Towards an SDR implementation of LoRa...\" 2020 A.Marquet,\
      \ N.Montavont, G.Papadopoulos)\n\"\"\"\n\nimport numpy as np\nfrom gnuradio\
      \ import gr\n\n\nclass Hamming_Rx(gr.sync_block):  # other base classes are\
      \ basic_block, decim_block, interp_block\n    def __init__(self, CR = 2):  #\
      \ only default arguments here\n        gr.sync_block.__init__(\n           \
      \ self,\n            name='LoRa Hamming Rx',   # will show up in GRC\n     \
      \       in_sig=[np.uint8],\n            out_sig=[np.uint8]\n        )\n    \
      \    self.CR = CR\n\n    def decode(self, input_vect, CR_loc) : \n\n       \
      \ output=input_vect\n\n        if CR_loc == 1:\n            syndrome = input_vect[0]\
      \ ^ input_vect[1] ^ input_vect[2] ^ input_vect[3] ^ input_vect[4]\n        \
      \    output = input_vect\n\n        if CR_loc == 2:\n            syndrome =\
      \ np.zeros((2,1), dtype=np.uint8)\n            syndrome[0] = input_vect[0] ^\
      \ input_vect[1] ^ input_vect[2] ^ input_vect[5]\n            syndrome[1] = input_vect[1]\
      \ ^ input_vect[2] ^ input_vect[3] ^ input_vect[4]\n            output = input_vect\n\
      \n        if CR_loc == 3:\n            n = 4+CR_loc\n            k = 4\n   \
      \         Q = np.array([[0,1,1], [1,1,0], [1,1,1], [1,0,1]], np.uint8)\n   \
      \         Id = np.identity(n-k, dtype=np.uint8)\n            H = np.concatenate((Q.transpose(),\
      \ Id),axis=1)\n            syndrome = np.dot(input_vect[:], H.transpose())%2\n\
      \n            tmp = np.zeros((1,n-k+4), dtype=np.uint8)\n            tmp2 =\
      \ np.identity(n-k+4, dtype=np.uint8)\n            E = np.concatenate((tmp, tmp2),axis=0)\n\
      \            S = np.dot(E,H.transpose())%2\n\n            # if(syndrome[0] ==\
      \ 1 or syndrome[1] == 1):\n            #     print(\"Error detected, correcting...\"\
      )\n\n            for j in range(S.shape[1]):\n                if np.array_equal(S[j],syndrome):\n\
      \                    output = input_vect ^ E[j][:]\n\n\n        if CR_loc ==\
      \ 4:\n            n = 4+CR_loc\n            k = 4\n            Q = np.array([[0,1,1,1],\
      \ [1,1,0,1], [1,1,1,0], [1,0,1,1]], np.uint8)\n            Id = np.identity(n-k,\
      \ dtype=np.uint8)\n            H = np.concatenate((Q.transpose(), Id),axis=1)\n\
      \            syndrome = np.dot(input_vect[:], H.transpose())%2\n           \
      \ if np.array_equal(syndrome,np.array([0,0,0,0])):\n                output =\
      \ input_vect\n                # print(\"no error detected\")\n\n           \
      \ else :\n                parity = input_vect[0] ^ input_vect[1] ^ input_vect[2]\
      \ ^ input_vect[3] ^ input_vect[4] ^ input_vect[5] ^ input_vect[6] ^ input_vect[7]\n\
      \n                if parity :\n                    # print(\"1 error detected,\
      \ sending to hamming(7,3)\")\n                    output = self.decode(input_vect[:][0:7],\
      \ 3)\n                # else :\n                    # print(\"2 errors detected\"\
      )\n                \n        \n        return output[:][0:4]\n\n    def work(self,\
      \ input_items, output_items):\n\n        in0 = input_items[0]\n        out =\
      \ output_items[0]\n    \n        # Hamming encoding (iterate over matrix lines\
      \ and encode each)\n        output_matrix = np.zeros((len(in0), 4), dtype=np.uint8)\n\
      \        input_matrix = np.zeros((len(in0), 4+self.CR), dtype=np.uint8)\n\n\
      \        for i in range(len(in0)):\n\n            # parsing in0 (convert + crop\
      \ to lines of 4 bits and bundle in matrix)\n            bits_crop = [int(x)\
      \ for x in bin(in0[i])[2:]]        \n            bits_crop_norm = ([0]*(self.CR+4-len(bits_crop))\
      \ + bits_crop)[-(self.CR+4):]\n            input_matrix[i][:] = np.asarray(bits_crop_norm,\
      \ dtype=np.uint8)\n\n            output_matrix[i][:] = self.decode(input_matrix[i][:],self.CR)\n\
      \n\n        # convert output matrix to uint8\n        out[:] = output_matrix.dot(1\
      \ << np.arange(output_matrix.shape[-1] - 1, -1, -1))\n\n        # # debug\n\
      \        # print(\"\\n--- GENERAL WORK : HAMMING_DEC ---\")\n        # print(\"\
      in0 :\")\n        # print(in0)\n        # print(\"input_matrix :\")\n      \
      \  # print(input_matrix)\n        # print(\"output_matrix :\")\n        # print(output_matrix)\n\
      \        # print(\"out :\")\n        # print(out)\n        # print(\"--- HAMMING_DEC\
      \ END---\")\n\n        return len(output_items[0])"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('LoRa Hamming Rx', 'Hamming_Rx', [('CR', '2')], [('0', 'byte', 1)],
      [('0', 'byte', 1)], '', ['CR'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [760, 644.0]
    rotation: 0
    state: disabled
- name: epy_block_1_0_0
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nWhitening block\nWhiten input sequence to remove the frequency\
      \ and time correlations in it.\n\n\"\"\"\nimport numpy as np\nfrom gnuradio\
      \ import gr\n\nwhitening_seq =(0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE1, 0xC2, 0x85,\
      \ 0x0B, 0x17, 0x2F, 0x5E, 0xBC, 0x78, 0xF1, 0xE3,\n                0xC6, 0x8D,\
      \ 0x1A, 0x34, 0x68, 0xD0, 0xA0, 0x40, 0x80, 0x01, 0x02, 0x04, 0x08, 0x11, 0x23,\
      \ 0x47,\n                0x8E, 0x1C, 0x38, 0x71, 0xE2, 0xC4, 0x89, 0x12, 0x25,\
      \ 0x4B, 0x97, 0x2E, 0x5C, 0xB8, 0x70, 0xE0,\n                0xC0, 0x81, 0x03,\
      \ 0x06, 0x0C, 0x19, 0x32, 0x64, 0xC9, 0x92, 0x24, 0x49, 0x93, 0x26, 0x4D, 0x9B,\n\
      \                0x37, 0x6E, 0xDC, 0xB9, 0x72, 0xE4, 0xC8, 0x90, 0x20, 0x41,\
      \ 0x82, 0x05, 0x0A, 0x15, 0x2B, 0x56,\n                0xAD, 0x5B, 0xB6, 0x6D,\
      \ 0xDA, 0xB5, 0x6B, 0xD6, 0xAC, 0x59, 0xB2, 0x65, 0xCB, 0x96, 0x2C, 0x58,\n\
      \                0xB0, 0x61, 0xC3, 0x87, 0x0F, 0x1F, 0x3E, 0x7D, 0xFB, 0xF6,\
      \ 0xED, 0xDB, 0xB7, 0x6F, 0xDE, 0xBD,\n                0x7A, 0xF5, 0xEB, 0xD7,\
      \ 0xAE, 0x5D, 0xBA, 0x74, 0xE8, 0xD1, 0xA2, 0x44, 0x88, 0x10, 0x21, 0x43,\n\
      \                0x86, 0x0D, 0x1B, 0x36, 0x6C, 0xD8, 0xB1, 0x63, 0xC7, 0x8F,\
      \ 0x1E, 0x3C, 0x79, 0xF3, 0xE7, 0xCE,\n                0x9C, 0x39, 0x73, 0xE6,\
      \ 0xCC, 0x98, 0x31, 0x62, 0xC5, 0x8B, 0x16, 0x2D, 0x5A, 0xB4, 0x69, 0xD2,\n\
      \                0xA4, 0x48, 0x91, 0x22, 0x45, 0x8A, 0x14, 0x29, 0x52, 0xA5,\
      \ 0x4A, 0x95, 0x2A, 0x54, 0xA9, 0x53,\n                0xA7, 0x4E, 0x9D, 0x3B,\
      \ 0x77, 0xEE, 0xDD, 0xBB, 0x76, 0xEC, 0xD9, 0xB3, 0x67, 0xCF, 0x9E, 0x3D,\n\
      \                0x7B, 0xF7, 0xEF, 0xDF, 0xBF, 0x7E, 0xFD, 0xFA, 0xF4, 0xE9,\
      \ 0xD3, 0xA6, 0x4C, 0x99, 0x33, 0x66,\n                0xCD, 0x9A, 0x35, 0x6A,\
      \ 0xD4, 0xA8, 0x51, 0xA3, 0x46, 0x8C, 0x18, 0x30, 0x60, 0xC1, 0x83, 0x07,\n\
      \                0x0E, 0x1D, 0x3A, 0x75, 0xEA, 0xD5, 0xAA, 0x55, 0xAB, 0x57,\
      \ 0xAF, 0x5F, 0xBE, 0x7C, 0xF9, 0xF2,\n                0xE5, 0xCA, 0x94, 0x28,\
      \ 0x50, 0xA1, 0x42, 0x84, 0x09, 0x13, 0x27, 0x4F, 0x9F, 0x3F, 0x7F)\n\nwhitening_seq_debug\
      \ =0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\n\nwhitening_seq = whitening_seq_debug\n\
      \nclass Whitening(gr.sync_block):  # other base classes are basic_block, decim_block,\
      \ interp_block\n    def __init__(self):  # only default arguments here\n   \
      \     gr.sync_block.__init__(\n            self,\n            name='LoRa Whitening',\
      \   # will show up in GRC\n            in_sig=[np.uint8],\n            out_sig=[np.uint8]\n\
      \        )\n        self.table_idx = 0\n        \n    def work(self, input_items,\
      \ output_items):\n        \n        in0 = input_items[0]\n        out = output_items[0]\n\
      \        # parsing in0 (convert + crop to lines of 4 bits and bundle in matrix)\n\
      \        input_matrix = np.zeros((len(in0), 4), dtype=np.uint8)\n        for\
      \ i in range(len(in0)):\n            bits_crop = [int(x) for x in bin(in0[i])[2:]]\
      \        \n            bits_crop_norm = ([0]*(4-len(bits_crop)) + bits_crop)[-(4):]\n\
      \            input_matrix[i][:] = np.asarray(bits_crop_norm, dtype=np.uint8)\n\
      \            \n            # whitening\n            out[i] = in0[i] ^ whitening_seq[self.table_idx]\n\
      \            self.table_idx += 1\n            if(self.table_idx == len(whitening_seq)):\n\
      \                self.table_idx = 0\n\n\n        # #debug\n        # print(\"\
      \\n--- GENERAL WORK : WHITENING ---\")\n        # print(\"in0 :\")\n       \
      \ # print(in0)\n        # print(\"input_matrix :\")\n        # print(input_matrix)\n\
      \        # print(\"out :\")\n        # print(out)\n        # print(\"return\
      \ len(out): \")\n        # print(len(out))\n        # print(\"--- WHITENING\
      \ END---\")\n\n        return len(out)\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('LoRa Whitening', 'Whitening', [], [('0', 'byte', 1)], [('0', 'byte',
      1)], '', [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [336, 440.0]
    rotation: 0
    state: enabled
- name: epy_block_1_1
  id: epy_block
  parameters:
    CR: CR
    _source_code: "\"\"\"\nHamming encoding block\nForward Error Correction encoding\
      \ block\nReference : \"Towards an SDR implementation of LoRa...\" 2020 A.Marquet,\
      \ N.Montavont, G.Papadopoulos)\n\"\"\"\n\nimport numpy as np\nfrom gnuradio\
      \ import gr\n\n\nclass Hamming_enc(gr.sync_block):  # other base classes are\
      \ basic_block, decim_block, interp_block\n    def __init__(self, CR = 4):  #\
      \ only default arguments here\n        gr.sync_block.__init__(\n           \
      \ self,\n            name='LoRa Hamming Tx',   # will show up in GRC\n     \
      \       in_sig=[np.uint8],\n            out_sig=[np.uint8]\n        )\n    \
      \    self.CR = CR\n\n    def work(self, input_items, output_items):\n      \
      \  \n        in0 = input_items[0]\n        out = output_items[0]\n    \n   \
      \     # Hamming encoding (iterate over matrix lines and encode each)\n     \
      \   output_matrix = np.zeros((len(in0), 4+self.CR), dtype=np.uint8)\n      \
      \  input_matrix = np.zeros((len(in0), 4), dtype=np.uint8)\n        for i in\
      \ range(len(in0)):\n\n            # parsing in0 (convert + crop to lines of\
      \ 4 bits and bundle in matrix)\n            bits_crop = [int(x) for x in bin(in0[i])[2:]]\
      \ \n            # print(bits_crop)      \n            bits_crop_norm = ([0]*(4-len(bits_crop))\
      \ + bits_crop)[-(4):]\n            input_matrix[i][:] = np.asarray(bits_crop_norm,\
      \ dtype=np.uint8)\n\n            if self.CR == 1:\n                p0 = input_matrix[i][0]\
      \ ^ input_matrix[i][1] ^ input_matrix[i][2] ^ input_matrix[i][3]\n         \
      \       output_matrix[i] = np.asarray([input_matrix[i][0], input_matrix[i][1],\
      \ input_matrix[i][2], input_matrix[i][3], p0], dtype=np.uint8)\n\n         \
      \   if self.CR == 2:\n                p0 = input_matrix[i][0] ^ input_matrix[i][1]\
      \ ^ input_matrix[i][2]\n                p1 = input_matrix[i][1] ^ input_matrix[i][2]\
      \ ^ input_matrix[i][3]\n                output_matrix[i] = np.asarray([input_matrix[i][0],\
      \ input_matrix[i][1], input_matrix[i][2], input_matrix[i][3], p1, p0], dtype=np.uint8)\n\
      \n            if self.CR == 3:\n                Q = np.array([[0,1,1,1], [1,1,0,1],\
      \ [1,1,1,0], [1,0,1,1]], np.uint8)\n                Id = np.identity(4, dtype=np.uint8)\n\
      \                G = np.concatenate((Id, Q),axis=1)\n                output_matrix[i]\
      \ = (np.dot(input_matrix[i],G)%2)[0:4+self.CR]\n\n            if self.CR ==\
      \ 4:\n                Q = np.array([[0,1,1,1], [1,1,0,1], [1,1,1,0], [1,0,1,1]],\
      \ np.uint8)\n                Id = np.identity(4, dtype=np.uint8)\n         \
      \       G = np.concatenate((Id, Q),axis=1)\n                output_matrix[i]\
      \ = (np.dot(input_matrix[i],G)%2)\n\n        # convert output matrix to uint8\n\
      \        out[:] = output_matrix.dot(1 << np.arange(output_matrix.shape[-1] -\
      \ 1, -1, -1))\n\n        # #debug\n        # print(\"\\n--- GENERAL WORK : HAMMING_ENC\
      \ ---\")\n        # print(\"in0 :\")\n        # print(in0)\n        # print(\"\
      input_matrix :\")\n        # print(input_matrix)\n        # print(\"output_matrix\
      \ :\")\n        # print(output_matrix)\n        # print(\"out :\")\n       \
      \ # print(out)\n        # print(\"--- HAMMING_ENC END---\")\n\n        return\
      \ len(output_items[0])\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('LoRa Hamming Tx', 'Hamming_enc', [('CR', '4')], [('0', 'byte', 1)],
      [('0', 'byte', 1)], '', ['CR'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [488, 436.0]
    rotation: 0
    state: enabled
- name: epy_block_2
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nDewhitening block\n\"\"\"\nimport numpy as np\nfrom gnuradio\
      \ import gr\n\nwhitening_seq =(0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE1, 0xC2, 0x85,\
      \ 0x0B, 0x17, 0x2F, 0x5E, 0xBC, 0x78, 0xF1, 0xE3,\n                0xC6, 0x8D,\
      \ 0x1A, 0x34, 0x68, 0xD0, 0xA0, 0x40, 0x80, 0x01, 0x02, 0x04, 0x08, 0x11, 0x23,\
      \ 0x47,\n                0x8E, 0x1C, 0x38, 0x71, 0xE2, 0xC4, 0x89, 0x12, 0x25,\
      \ 0x4B, 0x97, 0x2E, 0x5C, 0xB8, 0x70, 0xE0,\n                0xC0, 0x81, 0x03,\
      \ 0x06, 0x0C, 0x19, 0x32, 0x64, 0xC9, 0x92, 0x24, 0x49, 0x93, 0x26, 0x4D, 0x9B,\n\
      \                0x37, 0x6E, 0xDC, 0xB9, 0x72, 0xE4, 0xC8, 0x90, 0x20, 0x41,\
      \ 0x82, 0x05, 0x0A, 0x15, 0x2B, 0x56,\n                0xAD, 0x5B, 0xB6, 0x6D,\
      \ 0xDA, 0xB5, 0x6B, 0xD6, 0xAC, 0x59, 0xB2, 0x65, 0xCB, 0x96, 0x2C, 0x58,\n\
      \                0xB0, 0x61, 0xC3, 0x87, 0x0F, 0x1F, 0x3E, 0x7D, 0xFB, 0xF6,\
      \ 0xED, 0xDB, 0xB7, 0x6F, 0xDE, 0xBD,\n                0x7A, 0xF5, 0xEB, 0xD7,\
      \ 0xAE, 0x5D, 0xBA, 0x74, 0xE8, 0xD1, 0xA2, 0x44, 0x88, 0x10, 0x21, 0x43,\n\
      \                0x86, 0x0D, 0x1B, 0x36, 0x6C, 0xD8, 0xB1, 0x63, 0xC7, 0x8F,\
      \ 0x1E, 0x3C, 0x79, 0xF3, 0xE7, 0xCE,\n                0x9C, 0x39, 0x73, 0xE6,\
      \ 0xCC, 0x98, 0x31, 0x62, 0xC5, 0x8B, 0x16, 0x2D, 0x5A, 0xB4, 0x69, 0xD2,\n\
      \                0xA4, 0x48, 0x91, 0x22, 0x45, 0x8A, 0x14, 0x29, 0x52, 0xA5,\
      \ 0x4A, 0x95, 0x2A, 0x54, 0xA9, 0x53,\n                0xA7, 0x4E, 0x9D, 0x3B,\
      \ 0x77, 0xEE, 0xDD, 0xBB, 0x76, 0xEC, 0xD9, 0xB3, 0x67, 0xCF, 0x9E, 0x3D,\n\
      \                0x7B, 0xF7, 0xEF, 0xDF, 0xBF, 0x7E, 0xFD, 0xFA, 0xF4, 0xE9,\
      \ 0xD3, 0xA6, 0x4C, 0x99, 0x33, 0x66,\n                0xCD, 0x9A, 0x35, 0x6A,\
      \ 0xD4, 0xA8, 0x51, 0xA3, 0x46, 0x8C, 0x18, 0x30, 0x60, 0xC1, 0x83, 0x07,\n\
      \                0x0E, 0x1D, 0x3A, 0x75, 0xEA, 0xD5, 0xAA, 0x55, 0xAB, 0x57,\
      \ 0xAF, 0x5F, 0xBE, 0x7C, 0xF9, 0xF2,\n                0xE5, 0xCA, 0x94, 0x28,\
      \ 0x50, 0xA1, 0x42, 0x84, 0x09, 0x13, 0x27, 0x4F, 0x9F, 0x3F, 0x7F)\n\nwhitening_seq_debug\
      \ = 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\n\nwhitening_seq = whitening_seq_debug\n\
      \nclass LoRa_Dewhitening(gr.sync_block):  # other base classes are basic_block,\
      \ decim_block, interp_block\n    def __init__(self):  # only default arguments\
      \ here\n        gr.sync_block.__init__(\n            self,\n            name='LoRa\
      \ Dewhitening',   # will show up in GRC\n            in_sig=[np.uint8],\n  \
      \          out_sig=[np.uint8]\n        )\n        self.table_idx = 0\n     \
      \   \n    def work(self, input_items, output_items):\n\n\n        in0 = input_items[0]\n\
      \        out = output_items[0]\n        # parsing in0 (convert + crop to lines\
      \ of 4 bits and bundle in matrix)\n        input_matrix = np.zeros((len(in0),\
      \ 4), dtype=np.uint8)\n        for i in range(len(in0)):\n            bits_crop\
      \ = [int(x) for x in bin(in0[i])[2:]]        \n            bits_crop_norm =\
      \ ([0]*(4-len(bits_crop)) + bits_crop)[-(4):]\n            input_matrix[i][:]\
      \ = np.asarray(bits_crop_norm, dtype=np.uint8)\n            \n            #\
      \ dewhitening\n            out_temp = in0[i] ^ whitening_seq[self.table_idx]\n\
      \            bits_out_temp_crop = [int(x) for x in bin(out_temp)[2:]]      \
      \  \n            bits_out_temp_crop_norm = ([0]*(4-len(bits_out_temp_crop))\
      \ + bits_out_temp_crop)[-(4):]\n            # print(bits_out_temp_crop_norm)\n\
      \            output_items[0][i] = np.array(bits_out_temp_crop_norm).dot(1 <<\
      \ np.arange(np.array(bits_out_temp_crop_norm).shape[-1] - 1, -1, -1))\n    \
      \        self.table_idx += 1\n            if(self.table_idx == len(whitening_seq)):\n\
      \                self.table_idx = 0\n\n        # #debug\n        # print(\"\\\
      n--- GENERAL WORK : DEWHITENING ---\")\n        # print(\"in0 :\")\n       \
      \ # print(in0)\n        # print(\"input_matrix :\")\n        # print(input_matrix)\n\
      \        # print(\"out :\")\n        # print(output_items[0][:])\n        #\
      \ print(\"return len(out): \")\n        # print(len(output_items[0]))\n    \
      \    # print(\"--- DEWHITENING END---\")\n        return len(output_items[0])"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('LoRa Dewhitening', 'LoRa_Dewhitening', [], [('0', 'byte', 1)], [('0',
      'byte', 1)], '', [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [944, 648.0]
    rotation: 0
    state: disabled
- name: epy_block_3
  id: epy_block
  parameters:
    SF: '9'
    _source_code: "\"\"\"\nModulation Block:\n\"\"\"\n\nimport numpy as np\nfrom gnuradio\
      \ import gr\nimport math\n\ndef modulate(SF, id, os_factor) :\n    M  = pow(2,SF)\n\
      \    chirp = np.zeros((len(id),M*os_factor), dtype=np.complex64)\n\n    for\
      \ i in range(len(id)) :\n        n_fold = M * os_factor - id[i] * os_factor\n\
      \        for n in range(0,M*os_factor):\n            if n < n_fold:\n      \
      \          chirp[i][n] = np.exp(2j*math.pi *(n*n/(2*M)/pow(os_factor,2)+(id[i]/M-0.5)*n/os_factor))\n\
      \            else:\n                chirp[i][n] = np.exp(2j*math.pi *(n*n/(2*M)/pow(os_factor,2)+(id[i]/M-1.5)*n/os_factor))\n\
      \    \n    # chirp = np.reshape(chirp,-1)\n\n    return chirp\n\nclass blk(gr.sync_block):\
      \  # other base classes are basic_block, decim_block, interp_block\n\n    def\
      \ __init__(self, SF = 9, preamble_len = 4):  # only default arguments here\n\
      \        gr.sync_block.__init__(\n            self,\n            name='LoRa\
      \ Preamble',   # will show up in GRC\n            in_sig=None,\n           \
      \ # out_sig=[(np.complex64,pow(2,SF)*preamble_len+round(pow(2,SF)*2.25))]\n\
      \            out_sig=[(np.complex64,round(pow(2,SF)*(preamble_len+2.25)))]\n\
      \        )\n        self.SF = SF\n        self.preamble_len = preamble_len\n\
      \n    def work(self, input_items, output_items):\n\n        # for i in range\
      \ (len(symbols)) :\n        #     output_items[0][i] = modulate(self.SF, [symbols[i]],\
      \ 1)\n        \n        # preamble = np.zeros((self.preamble_len*pow(2,self.SF)),\
      \ dtype=np.complex64)\n        preamble_up = np.reshape(modulate(self.SF, [0]*self.preamble_len,\
      \ 1), -1)\n        preamble_down = np.reshape(np.conjugate(modulate(self.SF,\
      \ [0]*3, 1)), -1)[0:int(2.25*pow(2,self.SF))]\n        #  [:round(0.75*pow(2,self.SF))]\n\
      \        # print(preamble_up.shape)\n        # print(preamble_down.shape)\n\
      \        preamble = np.concatenate((preamble_up, preamble_down))\n        output_items[0][0]\
      \ = np.reshape(preamble,-1)\n\n\n        return len(output_items[0])"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    preamble_len: '4'
  states:
    _io_cache: ('LoRa Preamble', 'blk', [('SF', '9'), ('preamble_len', '4')], [],
      [('0', 'complex', 3200)], '', ['SF', 'preamble_len'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [808, 364.0]
    rotation: 0
    state: enabled
- name: epy_block_4
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nEmbedded Python Blocks:\n\nEach time this file is saved,\
      \ GRC will instantiate the first class it finds\nto get ports and parameters\
      \ of your block. The arguments to __init__  will\nbe the parameters. All of\
      \ them are required to have default values!\n\"\"\"\n\nimport numpy as np\n\
      from gnuradio import gr\n\nclass my_basic_adder_block(gr.basic_block):\n   \
      \ # def __init__(self):\n    #     gr.basic_block.__init__(self,\n    #    \
      \     name=\"test_blqsdock\",\n    #         in_sig=[np.uint8],\n    #     \
      \    out_sig=[np.uint8])\n\n    # def forecast(self, noutput_items, ninputs)\
      \ :\n    #     ninput_items_required = [0]*ninputs #ninput_items_required[i]\
      \ is the number of items that will be consumed on input port i\n    #     for\
      \ i in range(ninputs):\n    #         ninput_items_required[i] = 1.5 * noutput_items\
      \ * ninputs\n\n    #     # print(\"--- FORECAST ---\")\n    #     # print(ninputs)\n\
      \    #     # print(noutput_items)\n    #     # print(ninput_items_required)\n\
      \n    #     return ninput_items_required\n\n\n    # def general_work(self, input_items,\
      \ output_items):\n        \n    #     #buffer references\n    #     in0 = input_items[0][:len(output_items[0])]\n\
      \    #     out = output_items[0]\n        \n\n    #     output_items[0][:] =\
      \ in0\n\n\n    #     print(\"\\n--- GENERAL WORK 1  ---\")\n    #     print(\"\
      input_items[0]\")\n    #     print(input_items[0])\n    #     print(\"in0\"\
      )\n    #     print(in0)\n    #     print(\"len(in0)\")\n    #     print(len(in0))\n\
      \    #     print(\"output_items[0]\")\n    #     print(output_items[0])\n  \
      \  #     print(\"len(output_items[0])\")\n    #     print(len(output_items[0]))\n\
      \n    #     #consume the inputs\n    #     self.consume(0, len(in0)) #consume\
      \ port 0 input\n    #     # self.produce(0, 1) #produce 3 items on port 0\n\
      \    #     #return produced\n    #     return len(output_items[0])\n\n   def\
      \ __init__(self, input_buffer_len=2):\n      gr.basic_block.__init__(self,\n\
      \         name=\"sync_test\",\n         in_sig=[np.uint8],\n         out_sig=[np.uint8])\n\
      \      self.input_buffer_len = input_buffer_len\n\n   def forecast(self, noutput_items,\
      \ ninputs):\n    #   print(\"FORECAST START\")\n      ninput_items_required\
      \ = [self.input_buffer_len] * ninputs\n    #   print(\"len(ninput_items_required),noutput_items\"\
      ,len(ninput_items_required),noutput_items)\n    #   print(\"FORECAST END\")\n\
      \      return ninput_items_required\n\n   def general_work(self, input_items,\
      \ output_items):\n    print(\"\\n--- GENERAL WORK START ---\")\n    if(len(input_items[0])\
      \ >= self.input_buffer_len) :\n        out_vect = [0xFF, 0x55, 0xAA]\n     \
      \   output_items[0][0:len(out_vect)] = out_vect\n        self.consume(0, self.input_buffer_len)\n\
      \        self.produce(0, len(out_vect))\n\n\n        print(\"len(input_items)\"\
      , len(input_items[0]))\n        print(\"input_buffer_len\", self.input_buffer_len)\n\
      \        print(\"len(input_items[0]) >= input_buffer_len\")\n        print(\"\
      len(output_items[0])\", len(output_items[0]))\n        print(\"output_items[0]\
      \ = \")\n        print(output_items[0])\n\n    print(\"--- GENERAL WORK END\
      \ ---\")\n    return len(out_vect)"
    affinity: ''
    alias: ''
    comment: ''
    input_buffer_len: '2'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('sync_test', 'my_basic_adder_block', [('input_buffer_len', '2')],
      [('0', 'byte', 1)], [('0', 'byte', 1)], '', ['input_buffer_len'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1160, 108.0]
    rotation: 0
    state: disabled
- name: epy_block_5
  id: epy_block
  parameters:
    B: '250000'
    SF: SF
    _source_code: "\"\"\"\nDemodulation Block:\n\"\"\"\n\nimport numpy as np\nfrom\
      \ gnuradio import gr\nimport math\n\n# def modulate(SF, symbol, sign) :\n  \
      \  # M  = pow(2,SF)\n    # ka = np.arange(0,M)\n    # fact1 = np.exp(1j*sign*math.pi*pow(ka,2)/M)\n\
      \    # fact1 = np.reshape(fact1,(1,-1))\n    # symbK = np.multiply(fact1,np.exp(2j*math.pi*(symbol/M)*ka))\n\
      \    # return symbK\n    \ndef modulate(SF, id, os_factor) :\n    M  = pow(2,SF)\n\
      \    n_fold = M * os_factor - id * os_factor\n    chirp = np.zeros(M*os_factor,\
      \ dtype=np.complex64)\n    for n in range(0,M*os_factor):\n        if n < n_fold:\n\
      \            chirp[n] = np.exp(2j*math.pi *(n*n/(2*M)/pow(os_factor,2)+(id/M-0.5)*n/os_factor))\n\
      \        else:\n            chirp[n] = np.exp(2j*math.pi *(n*n/(2*M)/pow(os_factor,2)+(id/M-1.5)*n/os_factor))\n\
      \    return chirp\n\n\nclass blk(gr.sync_block):  # other base classes are basic_block,\
      \ decim_block, interp_block\n\n    def __init__(self, SF = 9, B = 250000): \
      \ # only default arguments here\n        \"\"\"arguments to this function show\
      \ up as parameters in GRC\"\"\"\n        gr.sync_block.__init__(\n         \
      \   self,\n            name='LoRa Demodulation',   # will show up in GRC\n \
      \           in_sig=[(np.complex64,512)],\n            # out_sig=[(np.complex64,512)]\n\
      \            out_sig=[np.uint32]\n        )\n        self.SF = SF\n        self.B\
      \ = B\n\n    def work(self, input_items, output_items):\n        \"\"\"example:\
      \ multiply with constant\"\"\"\n        base_upchirp = modulate(self.SF, 0,\
      \ 1)\n        base_downchirp = np.conjugate(base_upchirp)\n        M = pow(2,self.SF)\n\
      \        symbols_hat =  np.zeros(len(input_items[0]), dtype=np.uint32)\n   \
      \     for i in range(len(input_items[0])):\n            demod_signal = np.multiply(input_items[0][i],\
      \ base_downchirp)\n            demod_signal_fft = np.fft.fft(demod_signal)\n\
      \            idx = np.argmax(np.abs(demod_signal_fft))\n            freq_vect\
      \ = np.arange(0,M-1)*(self.B/M) # !!!! WILL INTRODUCE PROBLEMS WHEN OS_FACTOR\
      \ IS NOT 1 !!!!\n            output_items[0][i] = round(freq_vect[idx]*M/self.B)\n\
      \            symbols_hat[i] = round(freq_vect[idx]*M/self.B)\n        \n   \
      \     # # debug\n        # print(\"\\n--- GENERAL WORK : DEMODULATION ---\"\
      )\n        # print(\"symbols_hat :\")\n        # print(symbols_hat)\n\n    \
      \    return len(output_items[0])\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('LoRa Demodulation', 'blk', [('SF', '9'), ('B', '250000')], [('0',
      'complex', 512)], [('0', 'int', 1)], 'arguments to this function show up as
      parameters in GRC', ['B', 'SF'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [400, 636.0]
    rotation: 0
    state: disabled
- name: epy_block_6_0_0_0_0_0
  id: epy_block
  parameters:
    SF: SF
    _source_code: "\"\"\"\nModulation Block:\n\"\"\"\n\nimport numpy as np\nfrom gnuradio\
      \ import gr\nimport math\nimport pmt\n\ndef modulate(SF, id, os_factor) :\n\
      \    M  = pow(2,SF)\n    n_fold = M * os_factor - id * os_factor\n    chirp\
      \ = np.zeros(M*os_factor, dtype=np.complex64)\n    for n in range(0,M*os_factor):\n\
      \        if n < n_fold:\n            chirp[n] = np.exp(2j*math.pi *(n*n/(2*M)/pow(os_factor,2)+(id/M-0.5)*n/os_factor))\n\
      \        else:\n            chirp[n] = np.exp(2j*math.pi *(n*n/(2*M)/pow(os_factor,2)+(id/M-1.5)*n/os_factor))\n\
      \    return chirp\n\nclass blk(gr.sync_block):  # other base classes are basic_block,\
      \ decim_block, interp_block\n\n    def __init__(self, SF = 9):  # only default\
      \ arguments here\n        gr.sync_block.__init__(\n            self,\n     \
      \       name='LoRa Modulation',   # will show up in GRC\n            in_sig=[np.uint32],\n\
      \            out_sig=[(np.complex64,pow(2,SF))]\n        )\n        self.SF\
      \ = SF\n\n    def work(self, input_items, output_items):\n        \n       \
      \ symbols = input_items[0]\n\n        for i in range (len(symbols)) :\n    \
      \        output_items[0][i] = modulate(self.SF, symbols[i], 1)\n\n\n       \
      \ # tags = self.get_tags_in_window(0, 0, len(input_items[0]))\n        # #if\
      \ there exist tag\n        # if len(tags) > 0:\n        #     #for each tag\
      \ apply\n        #     for tag in tags:\n        #         tag_name   = pmt.to_python(tag.key)\
      \            # packet_tag\n        #         tag_len    = pmt.to_python(tag.value)\
      \          # packet_len\n        #         tag_pos    = tag.offset - self.nitems_read(0)\
      \  # packet_position_index\n        #         print(\"tag_name :\", tag_name,\
      \ \"\\ntag_len :\", tag_len, \"\\ntag_pos:\", tag_pos)\n\n        return len(output_items[0])"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('LoRa Modulation', 'blk', [('SF', '9')], [('0', 'int', 1)], [('0',
      'complex', 512)], '', ['SF'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [808, 436.0]
    rotation: 0
    state: enabled
- name: qtgui_time_sink_x_0
  id: qtgui_time_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: blue
    color10: dark blue
    color2: red
    color3: green
    color4: black
    color5: cyan
    color6: magenta
    color7: yellow
    color8: dark red
    color9: dark green
    comment: ''
    ctrlpanel: 'False'
    entags: 'True'
    grid: 'False'
    gui_hint: ''
    label1: Signal 1
    label10: Signal 10
    label2: Signal 2
    label3: Signal 3
    label4: Signal 4
    label5: Signal 5
    label6: Signal 6
    label7: Signal 7
    label8: Signal 8
    label9: Signal 9
    legend: 'True'
    marker1: '-1'
    marker10: '-1'
    marker2: '-1'
    marker3: '-1'
    marker4: '-1'
    marker5: '-1'
    marker6: '-1'
    marker7: '-1'
    marker8: '-1'
    marker9: '-1'
    name: '""'
    nconnections: '1'
    size: 512*9+round(pow(2,SF)*(preamble_len+2.25))
    srate: samp_rate
    stemplot: 'False'
    style1: '1'
    style10: '1'
    style2: '1'
    style3: '1'
    style4: '1'
    style5: '1'
    style6: '1'
    style7: '1'
    style8: '1'
    style9: '1'
    tr_chan: '0'
    tr_delay: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: complex
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    ylabel: Amplitude
    ymax: '1'
    ymin: '-1'
    yunit: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1368, 348.0]
    rotation: 0
    state: enabled

connections:
- [blocks_stream_mux_0, '0', blocks_file_sink_1, '0']
- [blocks_stream_mux_0, '0', qtgui_time_sink_x_0, '0']
- [blocks_vector_source_x_0_0_0_0, '0', epy_block_1_0_0, '0']
- [blocks_vector_source_x_0_1, '0', epy_block_4, '0']
- [blocks_vector_to_stream_0_0_0, '0', blocks_stream_mux_0, '0']
- [blocks_vector_to_stream_0_0_1, '0', blocks_stream_mux_0, '1']
- [epy_block_0, '0', epy_block_1, '0']
- [epy_block_0_1_0_0, '0', epy_block_6_0_0_0_0_0, '0']
- [epy_block_1, '0', epy_block_2, '0']
- [epy_block_1_0_0, '0', epy_block_1_1, '0']
- [epy_block_1_1, '0', epy_block_0_1_0_0, '0']
- [epy_block_2, '0', blocks_file_sink_0_1, '0']
- [epy_block_3, '0', blocks_vector_to_stream_0_0_0, '0']
- [epy_block_4, '0', blocks_file_sink_0_0, '0']
- [epy_block_5, '0', epy_block_0, '0']
- [epy_block_6_0_0_0_0_0, '0', blocks_vector_to_stream_0_0_1, '0']
- [epy_block_6_0_0_0_0_0, '0', epy_block_5, '0']

metadata:
  file_format: 1
