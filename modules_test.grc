options:
  parameters:
    author: ''
    catch_exceptions: 'True'
    category: '[GRC Hier Blocks]'
    cmake_opt: ''
    comment: ''
    copyright: ''
    description: ''
    gen_cmake: 'On'
    gen_linking: dynamic
    generate_options: no_gui
    hier_block_src_path: '.:'
    id: modules_test
    max_nouts: '0'
    output_language: python
    placement: (0,0)
    qt_qss_theme: ''
    realtime_scheduling: ''
    run: 'True'
    run_command: '{python} -u {filename}'
    run_options: prompt
    sizing_mode: fixed
    thread_safe_setters: ''
    title: Not titled yet
    window_size: (1000,1000)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [40, 20.0]
    rotation: 0
    state: enabled

blocks:
- name: CR
  id: variable
  parameters:
    comment: ''
    value: '2'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [488, 36.0]
    rotation: 0
    state: enabled
- name: SF
  id: variable
  parameters:
    comment: ''
    value: '9'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [416, 36.0]
    rotation: 0
    state: enabled
- name: frame_len
  id: variable
  parameters:
    comment: ''
    value: '18'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [224, 100.0]
    rotation: 0
    state: enabled
- name: preamble_len
  id: variable
  parameters:
    comment: ''
    value: '6'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [216, 36.0]
    rotation: 0
    state: enabled
- name: samp_rate
  id: variable
  parameters:
    comment: ''
    value: '32000'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [320, 36.0]
    rotation: 0
    state: enabled
- name: blocks_file_sink_0
  id: blocks_file_sink
  parameters:
    affinity: ''
    alias: ''
    append: 'False'
    comment: ''
    file: dumpIN
    type: byte
    unbuffered: 'False'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [656, 36.0]
    rotation: 0
    state: disabled
- name: blocks_file_sink_0_0
  id: blocks_file_sink
  parameters:
    affinity: ''
    alias: ''
    append: 'False'
    comment: ''
    file: dump
    type: byte
    unbuffered: 'False'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1352, 36.0]
    rotation: 0
    state: disabled
- name: blocks_file_sink_0_1
  id: blocks_file_sink
  parameters:
    affinity: ''
    alias: ''
    append: 'False'
    comment: ''
    file: dumpOUT
    type: byte
    unbuffered: 'False'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1088, 964.0]
    rotation: 0
    state: enabled
- name: blocks_file_sink_0_2
  id: blocks_file_sink
  parameters:
    affinity: ''
    alias: ''
    append: 'False'
    comment: ''
    file: dumpOUT
    type: byte
    unbuffered: 'False'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [816, 36.0]
    rotation: 0
    state: disabled
- name: blocks_file_sink_0_3
  id: blocks_file_sink
  parameters:
    affinity: ''
    alias: ''
    append: 'False'
    comment: ''
    file: dumpIN
    type: byte
    unbuffered: 'False'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [312, 340.0]
    rotation: 0
    state: enabled
- name: blocks_file_sink_1
  id: blocks_file_sink
  parameters:
    affinity: ''
    alias: ''
    append: 'False'
    comment: ''
    file: lora_frame
    type: complex
    unbuffered: 'False'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [888, 596.0]
    rotation: 0
    state: disabled
- name: blocks_file_sink_2_0
  id: blocks_file_sink
  parameters:
    affinity: ''
    alias: ''
    append: 'False'
    comment: ''
    file: payloadOUT
    type: complex
    unbuffered: 'False'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1224, 676.0]
    rotation: 0
    state: enabled
- name: blocks_file_sink_4
  id: blocks_file_sink
  parameters:
    affinity: ''
    alias: ''
    append: 'False'
    comment: ''
    file: preamble
    type: complex
    unbuffered: 'False'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1192, 188.0]
    rotation: 0
    state: disabled
- name: blocks_stream_mux_1
  id: blocks_stream_mux
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    lengths: (8, round(pow(2,SF)*(preamble_len+2.25)), 18*512)
    maxoutbuf: '0'
    minoutbuf: '0'
    num_inputs: '3'
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1200, 360.0]
    rotation: 0
    state: enabled
- name: blocks_stream_to_vector_0
  id: blocks_stream_to_vector
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    num_items: pow(2,SF)
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [176, 984.0]
    rotation: 0
    state: enabled
- name: blocks_tagged_stream_align_1
  id: blocks_tagged_stream_align
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    lengthtagname: '"preamble_end"'
    maxoutbuf: '0'
    minoutbuf: '0'
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [752, 692.0]
    rotation: 0
    state: enabled
- name: blocks_vector_source_x_0
  id: blocks_vector_source_x
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    repeat: 'False'
    tags: '[]'
    type: complex
    vector: (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0)
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [912, 260.0]
    rotation: 0
    state: enabled
- name: blocks_vector_source_x_0_0_0_0
  id: blocks_vector_source_x
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    repeat: 'False'
    tags: '[]'
    type: byte
    vector: (0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c,
      0x0d, 0x0e, 0x0f, 0x0e, 0x0d, 0x0c)
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [104, 420.0]
    rotation: 0
    state: enabled
- name: blocks_vector_source_x_0_1
  id: blocks_vector_source_x
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    repeat: 'False'
    tags: '[]'
    type: byte
    vector: (0xFF, 0x7F, 0x3F, 0x1F, 0x1F, 0x1F)
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [976, 36.0]
    rotation: 0
    state: disabled
- name: blocks_vector_to_stream_0_0_0
  id: blocks_vector_to_stream
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    num_items: round(pow(2,SF)*(preamble_len+2.25))
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [984, 376.0]
    rotation: 0
    state: enabled
- name: blocks_vector_to_stream_0_0_1
  id: blocks_vector_to_stream
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    num_items: pow(2,SF)
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [984, 440.0]
    rotation: 0
    state: enabled
- name: epy_block_0
  id: epy_block
  parameters:
    CR: CR
    SF: SF
    _source_code: "\"\"\"\nDeinterleaving block\nInverse of interleaving block.\n\
      Reference : \"Towards an SDR implementation of LoRa...\" 2020 A.Marquet, N.Montavont,\
      \ G.Papadopoulos)\n\nINPUT:\n    - in_sig[0]: CR int32 input sequence\nOUTPUT:\n\
      \    - out_sig[0]: SF bytes output sequence (4+CR useful bits per byte)\n\"\"\
      \"\n\nimport numpy as np\nfrom gnuradio import gr\n\nclass Deinterleaver(gr.basic_block):\n\
      \    def __init__(self, SF=9, CR=2):\n        gr.basic_block.__init__(self,\n\
      \            name=\"LoRa Deinterleaver\",\n            in_sig=[np.uint32],\n\
      \            out_sig=[np.uint8])\n        self.SF = SF\n        self.CR = CR\n\
      \n    def forecast(self, noutput_items, ninputs) :\n        #ninput_items_required[i]\
      \ is the number of items that will be consumed on input port i\n        ninput_items_required\
      \ = [self.CR+4]*ninputs # we need CR+4 items to produce anything\n        return\
      \ ninput_items_required\n\n    def general_work(self, input_items, output_items):\n\
      \        \n        if(len(input_items[0]) >= self.CR+4) :  # if we have enough\
      \ items to process\n\n            in0 = input_items[0][:self.CR+4]    # input\
      \ buffer reference\n\n            # formatting the input buffer\n          \
      \  input_matrix = np.zeros((self.CR+4, self.SF), dtype=np.uint8)\n         \
      \   for i in range(len(in0)):\n                bits_crop = [int(x) for x in\
      \ bin(in0[i])[2:]]                               # convert to binary       \
      \  \n                bits_crop_norm = ([0]*(self.SF-len(bits_crop)) + bits_crop)[-(self.SF):]\
      \    # crop to SF bits\n                input_matrix[i][:] = np.asarray(bits_crop_norm,\
      \ dtype=np.uint8)             # convert to np.array\n\n            # deinterleaving\n\
      \            output_matrix = np.zeros((self.SF, self.CR+4), dtype=np.uint8)\n\
      \            for i in range(0,(self.SF)) :\n                for j in range(0,(self.CR+4))\
      \ :\n                    idi=self.CR+4-1-j\n                    idj=(self.SF-1-i+(self.CR+4)-1-j)%self.SF\n\
      \                    output_matrix[i][j]=input_matrix[idi][idj]\n\n        \
      \    # to uint32\n            output_items[0][0:(self.SF)] = output_matrix.dot(1\
      \ << np.arange(output_matrix.shape[-1] - 1, -1, -1))\n\n            # # debug\n\
      \            # print(\"\\n--- GENERAL WORK : DEINTERLEAVER ---\")\n        \
      \    # print(\"in0 :\")\n            # print(in0)\n            # print(\"len(in0)\
      \ (should be CR+4): \")\n            # print(len(in0))\n            # print(\"\
      input_matrix (CR+4 x SF):\")\n            # print(input_matrix)\n          \
      \  # print(\"output_matrix (SF x CR+4 ):\")\n            # print(output_matrix)\n\
      \            # print(\"output_items[0] = \")\n            # print(output_items[0][0:(self.SF)])\n\
      \            # print(\"return len(output_items[0]) (should be CR+4): \")\n \
      \           # print(len(output_items[0]))\n\n            self.consume(0, self.CR+4)\
      \  # consume inputs (should be CR+4)\n            return self.SF           \
      \   # return produced outputs (should be SF)\n\n        else :\n           \
      \ return 0"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('LoRa Deinterleaver', 'Deinterleaver', [('SF', '9'), ('CR', '2')],
      [('0', 'int', 1)], [('0', 'byte', 1)], '', ['CR', 'SF'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [536, 972.0]
    rotation: 0
    state: enabled
- name: epy_block_0_1_0_0
  id: epy_block
  parameters:
    CR: CR
    SF: SF
    _source_code: "\"\"\"\nInterleaving block\nScrambles bits together to fight error\
      \ bursts.\nReference : \"Towards an SDR implementation of LoRa...\" 2020 A.Marquet,\
      \ N.Montavont, G.Papadopoulos)\n\nINPUT:\n    - in_sig[0]: SF bytes input sequence\
      \ (4+CR useful bits per byte)\nOUTPUT:\n    - out_sig[0]: CR int32 output sequence\n\
      \"\"\"\n\nimport numpy as np\nfrom gnuradio import gr\n\nclass Interleaver(gr.basic_block):\n\
      \    def __init__(self, SF=9, CR=4):\n        gr.basic_block.__init__(self,\n\
      \            name=\"LoRa Interleaver\",\n            in_sig=[np.uint8],\n  \
      \          out_sig=[np.uint32])\n        self.SF = SF\n        self.CR = CR\n\
      \n    def forecast(self, noutput_items, ninputs) :\n        #ninput_items_required[i]\
      \ is the number of items that will be consumed on input port i\n        ninput_items_required\
      \ = [self.SF]*ninputs   # we need SF items to produce anything\n        return\
      \ ninput_items_required\n\n    def general_work(self, input_items, output_items):\n\
      \        \n        if(len(input_items[0]) >= self.SF) :    # if we have enough\
      \ items to process\n\n            in0 = input_items[0][:self.SF]  # input buffer\
      \ reference\n\n            # formatting the input buffer\n            input_matrix\
      \ = np.zeros((self.SF, self.CR+4), dtype=np.uint8)\n            for i in range(len(in0)):\n\
      \                bits_crop = [int(x) for x in bin(in0[i])[2:]]             \
      \                      # convert to binary  \n                bits_crop_norm\
      \ = ([0]*(self.CR+4-len(bits_crop)) + bits_crop)[-(self.CR+4):]    # crop to\
      \ 4+CR bits\n                input_matrix[i][:] = np.asarray(bits_crop_norm,\
      \ dtype=np.uint8)                 # convert to np.array\n\n            # interleaving\n\
      \            output_matrix = np.zeros((self.CR+4, self.SF), dtype=np.uint8)\n\
      \            for i in range(0,(self.CR+4)) :\n                for j in range(0,(self.SF))\
      \ :\n                    idi=self.SF-1-(j-i)%self.SF\n                    idj=self.CR+4-1-i\n\
      \                    output_matrix[i][j]=input_matrix[idi][idj]\n          \
      \  \n            # to uint32\n            output_items[0][0:(self.CR+4)] = output_matrix.dot(1\
      \ << np.arange(output_matrix.shape[-1] - 1, -1, -1))\n\n            # # debug\n\
      \            # print(\"\\n--- GENERAL WORK : INTERLEAVER ---\")\n          \
      \  # print(\"in0 :\")\n            # print(in0)\n            # print(\"len(in0)\
      \ (should be SF): \")\n            # print(len(in0))\n            # print(\"\
      input_matrix (SF x CR+4):\")\n            # print(input_matrix)\n          \
      \  # print(\"output_matrix (CR+4 x SF):\")\n            # print(output_matrix)\n\
      \            # print(\"output_items[0] = \")\n            # print(output_items[0])\n\
      \n            self.consume(0, self.SF)    # consume inputs (should be SF)\n\
      \            return self.CR+4            # return produced outputs (should be\
      \ CR+4)\n\n        else :\n            return 0\n\n\n\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('LoRa Interleaver', 'Interleaver', [('SF', '9'), ('CR', '4')], [('0',
      'byte', 1)], [('0', 'int', 1)], '', ['CR', 'SF'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [648, 428.0]
    rotation: 0
    state: enabled
- name: epy_block_0_1_0_0_0
  id: epy_block
  parameters:
    B: '250000'
    SF: SF
    _source_code: "\"\"\"\nLoRa sync block\n\"\"\"\n\nimport numpy as np\nfrom gnuradio\
      \ import gr\nimport math\n\n\ndef modulate(SF, id, os_factor) :\n    M  = pow(2,SF)\n\
      \    n_fold = M * os_factor - id * os_factor\n    chirp = np.zeros(M*os_factor,\
      \ dtype=np.complex64)\n    for n in range(0,M*os_factor):\n        if n < n_fold:\n\
      \            chirp[n] = np.exp(2j*math.pi *(n*n/(2*M)/pow(os_factor,2)+(id/M-0.5)*n/os_factor))\n\
      \        else:\n            chirp[n] = np.exp(2j*math.pi *(n*n/(2*M)/pow(os_factor,2)+(id/M-1.5)*n/os_factor))\n\
      \    return chirp\n\nclass Sync(gr.basic_block):\n    def __init__(self, SF=9,\
      \ B=250000, preamble_len= 6):\n        gr.basic_block.__init__(self,\n     \
      \       name=\"LoRa Sync\",\n            in_sig=[np.complex64],\n          \
      \  out_sig=[np.complex64])\n        self.SF = SF\n        self.currentState\
      \ = 'WAIT'\n        self.B = B\n        self.preamble_len = preamble_len\n \
      \       self.receivedBlocksCounter = 1\n\n    def forecast(self, noutput_items,\
      \ ninputs) :\n        #ninput_items_required[i] is the number of items that\
      \ will be consumed on input port i\n        # we need 2^SF items to produce\
      \ anything\n        ninput_items_required = [pow(2,self.SF)]*ninputs \n    \
      \    return ninput_items_required\n\n    def general_work(self, input_items,\
      \ output_items):\n        M = pow(2,self.SF)\n        threshold = M/2\n    \
      \    syncword = 0\n\n        if(len(input_items[0]) >= pow(2,self.SF)) :\n\n\
      \            base_upchirp = modulate(self.SF, 0, 1)\n            base_downchirp\
      \ = np.conjugate(base_upchirp)\n            demod_signal = np.multiply(input_items[0][:M],\
      \ base_downchirp)\n            demod_signal_fft = np.fft.fft(demod_signal)\n\
      \            peak = int(np.max(np.abs(demod_signal_fft)))\n            idx =\
      \ np.argmax(np.abs(demod_signal_fft))\n            freq_vect = np.arange(0,M-1)*(self.B/M)\
      \ # !!!! WILL INTRODUCE PROBLEMS WHEN OS_FACTOR IS NOT 1 !!!!\n            symbols_hat\
      \ = round(freq_vect[idx]*M/self.B)\n            \n            if(self.currentState\
      \ == 'WAIT') :\n                if peak > threshold :\n                    self.currentState\
      \ = 'UPCHIRPS'\n                else :\n                    self.consume(0,\
      \ M)\n\n            if self.currentState == 'UPCHIRPS' :\n                if\
      \ peak < threshold :\n                    self.currentState = 'WAIT'\n     \
      \           f_up = idx\n                if idx == 0 :\n                    self.receivedBlocksCounter\
      \ += 1\n                    if self.receivedBlocksCounter >= self.preamble_len-2\
      \ :\n                        self.currentState = 'SYNCWORD'\n              \
      \  self.consume(0, M)\n\n            if self.currentState == 'SYNCWORD' :\n\
      \                if peak < threshold :\n                    self.currentState\
      \ = 'WAIT'\n                if idx == syncword :\n                    self.receivedBlocksCounter\
      \ += 1\n                if self.receivedBlocksCounter >= self.preamble_len :\n\
      \                    self.currentState = 'DOWNCHIRPS'\n                self.consume(0,\
      \ M)\n\n            if self.currentState == 'DOWNCHIRPS' :\n               \
      \ demod_signal = np.multiply(input_items[0][:M], base_upchirp)\n           \
      \     demod_signal_fft = np.fft.fft(demod_signal)\n                peak = int(np.max(np.abs(demod_signal_fft)))\n\
      \                idx = np.argmax(np.abs(demod_signal_fft))\n               \
      \ freq_vect = np.arange(0,M-1)*(self.B/M) # !!!! WILL INTRODUCE PROBLEMS WHEN\
      \ OS_FACTOR IS NOT 1 !!!!\n                f_down = idx\n                self.receivedBlocksCounter\
      \ += 1\n\n                if self.receivedBlocksCounter > self.preamble_len+2\
      \ :\n                    self.consume(0, M*0.25)\n                    self.currentState\
      \ = 'SYNC'\n                else : \n                    self.consume(0, M)\n\
      \            if self.currentState == 'SYNC' :\n                CFOint = ((f_down\
      \ + f_up)/2)*self.B\n                STOint = (1-(f_down + f_up)/2)*M\n    \
      \            output_items[0][0:M] = input_items[0][0:M] # pass thru\n      \
      \          self.consume(0, M)\n\n            print(\"\\n--- Frame Sync ---\"\
      )\n            print(self.currentState)\n            print(\"receivedBlockCounter:\
      \ \", self.receivedBlocksCounter)\n            print(\"idx: \", idx)\n     \
      \       print(\"peak: \", peak)\n\n\n            \n            return 0\n  \
      \      else :\n            return 0\n\n\n\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    preamble_len: preamble_len
  states:
    _io_cache: ('LoRa Sync', 'Sync', [('SF', '9'), ('B', '250000'), ('preamble_len',
      '6')], [('0', 'complex', 1)], [('0', 'complex', 1)], '', ['B', 'SF', 'preamble_len'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [304, 708.0]
    rotation: 0
    state: disabled
- name: epy_block_1
  id: epy_block
  parameters:
    CR: CR
    _source_code: "\"\"\"\nHamming decoding block\nForward Error Correction decoding\
      \ block.\nReference : \"MIT EECS II : http://web.mit.edu/6.02/www/f2012/handouts/L05_slides.pdf\"\
      \n\nINPUT:\n    - in_sig[0]: binary input sequence (4+CR useful bits per byte)\n\
      OUTPUT:\n    - out_sig[0]: binary output sequence (4 useful bits per byte)\n\
      \"\"\"\n\nimport numpy as np\nfrom gnuradio import gr\n\n\nclass HammingRx(gr.sync_block):\n\
      \    def __init__(self, CR = 2):\n        gr.sync_block.__init__(\n        \
      \    self,\n            name='LoRa Hamming Rx',\n            in_sig=[np.uint8],\n\
      \            out_sig=[np.uint8]\n        )\n        self.CR = CR\n\n    def\
      \ decode(self, input_vect, CR_loc) : \n\n        output=input_vect\n\n     \
      \   if CR_loc == 1: # CR = 1, no error correction\n            \n          \
      \  syndrome = input_vect[0] ^ input_vect[1] ^ input_vect[2] ^ input_vect[3]\
      \ ^ input_vect[4]\n            output = input_vect\n\n        if CR_loc == 2:\
      \ # CR = 2, no error correction\n            \n            syndrome = np.zeros((2,1),\
      \ dtype=np.uint8)\n            syndrome[0] = input_vect[0] ^ input_vect[1] ^\
      \ input_vect[2] ^ input_vect[5]\n            syndrome[1] = input_vect[1] ^ input_vect[2]\
      \ ^ input_vect[3] ^ input_vect[4]\n            output = input_vect\n\n     \
      \   if CR_loc == 3: # CR = 3, 1 error correction is possible\n            \n\
      \            n = 4+CR_loc\n            k = 4\n\n            # compute syndrome\
      \ of input_vect\n            Q = np.array([[0,1,1], [1,1,0], [1,1,1], [1,0,1]],\
      \ np.uint8)\n            Id = np.identity(n-k, dtype=np.uint8)\n           \
      \ H = np.concatenate((Q.transpose(), Id),axis=1)\n            syndrome = np.dot(input_vect[:],\
      \ H.transpose())%2\n\n            # compute syndromes lookup table\n       \
      \     tmp = np.zeros((1,n-k+4), dtype=np.uint8)\n            tmp2 = np.identity(n-k+4,\
      \ dtype=np.uint8)\n            E = np.concatenate((tmp, tmp2),axis=0)\n    \
      \        S = np.dot(E,H.transpose())%2   \n\n            for j in range(S.shape[1]):\
      \             # iterate through the syndromes lookup table\n               \
      \ if np.array_equal(S[j],syndrome):   # if found, correct the input_vect\n \
      \                   output = input_vect ^ E[j][:]\n\n        if CR_loc == 4:\
      \ # CR = 4, 1 error correction is possible, 2 error detection is possible\n\
      \            \n            n = 4+CR_loc\n            k = 4\n\n            #\
      \ compute syndrome of input_vect\n            Q = np.array([[0,1,1,1], [1,1,0,1],\
      \ [1,1,1,0], [1,0,1,1]], np.uint8)\n            Id = np.identity(n-k, dtype=np.uint8)\n\
      \            H = np.concatenate((Q.transpose(), Id),axis=1)\n            syndrome\
      \ = np.dot(input_vect[:], H.transpose())%2\n\n\n            if np.array_equal(syndrome,np.array([0,0,0,0])):\
      \    # if no error, return input_vect\n                output = input_vect\n\
      \n            else :\n\n                # compute parity bit\n             \
      \   parity = input_vect[0] ^ input_vect[1] ^ input_vect[2] ^ input_vect[3] ^\
      \ input_vect[4] ^ input_vect[5] ^ input_vect[6] ^ input_vect[7]\n          \
      \      \n                if parity : # 1 error correctable\n               \
      \     output = self.decode(input_vect[:][0:7], 3) # correct the first 7 bits\
      \ by sending them to the decoding function\n        \n                else :\
      \  # 2 errors detected\n                    pass\n        return output[:][0:4]\
      \ # return the first 4 bits (data bits)\n\n    def work(self, input_items, output_items):\n\
      \n        in0 = input_items[0]    # input buffer reference\n        out = output_items[0]\
      \   # output buffer reference\n    \n        output_matrix = np.zeros((len(in0),\
      \ 4), dtype=np.uint8)\n        input_matrix = np.zeros((len(in0), 4+self.CR),\
      \ dtype=np.uint8)\n\n        for i in range(len(in0)):\n            bits_crop\
      \ = [int(x) for x in bin(in0[i])[2:]]                                   # convert\
      \ to binary\n            bits_crop_norm = ([0]*(self.CR+4-len(bits_crop)) +\
      \ bits_crop)[-(self.CR+4):]    # crop to 4+CR bits\n            input_matrix[i][:]\
      \ = np.asarray(bits_crop_norm, dtype=np.uint8)                 # convert to\
      \ np.array\n            output_matrix[i][:] = self.decode(input_matrix[i][:],self.CR)\
      \                   # send to decoding function\n\n        # convert output\
      \ matrix to uint8\n        out[:] = output_matrix.dot(1 << np.arange(output_matrix.shape[-1]\
      \ - 1, -1, -1))\n\n        # # debug\n        # print(\"\\n--- GENERAL WORK\
      \ : HAMMING_DEC ---\")\n        # print(\"in0 :\")\n        # print(in0)\n \
      \       # print(\"input_matrix :\")\n        # print(input_matrix)\n       \
      \ # print(\"output_matrix :\")\n        # print(output_matrix)\n        # print(\"\
      out :\")\n        # print(out)\n        # print(\"--- HAMMING_DEC END---\")\n\
      \n        return len(output_items[0])"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('LoRa Hamming Rx', 'HammingRx', [('CR', '2')], [('0', 'byte', 1)],
      [('0', 'byte', 1)], '', ['CR'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [712, 980.0]
    rotation: 0
    state: enabled
- name: epy_block_1_0_0
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nWhitening block\nWhiten input sequence to remove the frequency\
      \ and time correlations in it.\n\nINPUT:\n    - in_sig[0]: binary input sequence\
      \ (4 useful bits per byte)\nOUTPUT:\n    - out_sig[0]: whitened binary sequence\n\
      \"\"\"\n\nimport numpy as np\nfrom gnuradio import gr\n\nwhitening_seq =(0xFF,\
      \ 0xFE, 0xFC, 0xF8, 0xF0, 0xE1, 0xC2, 0x85, 0x0B, 0x17, 0x2F, 0x5E, 0xBC, 0x78,\
      \ 0xF1, 0xE3,\n                0xC6, 0x8D, 0x1A, 0x34, 0x68, 0xD0, 0xA0, 0x40,\
      \ 0x80, 0x01, 0x02, 0x04, 0x08, 0x11, 0x23, 0x47,\n                0x8E, 0x1C,\
      \ 0x38, 0x71, 0xE2, 0xC4, 0x89, 0x12, 0x25, 0x4B, 0x97, 0x2E, 0x5C, 0xB8, 0x70,\
      \ 0xE0,\n                0xC0, 0x81, 0x03, 0x06, 0x0C, 0x19, 0x32, 0x64, 0xC9,\
      \ 0x92, 0x24, 0x49, 0x93, 0x26, 0x4D, 0x9B,\n                0x37, 0x6E, 0xDC,\
      \ 0xB9, 0x72, 0xE4, 0xC8, 0x90, 0x20, 0x41, 0x82, 0x05, 0x0A, 0x15, 0x2B, 0x56,\n\
      \                0xAD, 0x5B, 0xB6, 0x6D, 0xDA, 0xB5, 0x6B, 0xD6, 0xAC, 0x59,\
      \ 0xB2, 0x65, 0xCB, 0x96, 0x2C, 0x58,\n                0xB0, 0x61, 0xC3, 0x87,\
      \ 0x0F, 0x1F, 0x3E, 0x7D, 0xFB, 0xF6, 0xED, 0xDB, 0xB7, 0x6F, 0xDE, 0xBD,\n\
      \                0x7A, 0xF5, 0xEB, 0xD7, 0xAE, 0x5D, 0xBA, 0x74, 0xE8, 0xD1,\
      \ 0xA2, 0x44, 0x88, 0x10, 0x21, 0x43,\n                0x86, 0x0D, 0x1B, 0x36,\
      \ 0x6C, 0xD8, 0xB1, 0x63, 0xC7, 0x8F, 0x1E, 0x3C, 0x79, 0xF3, 0xE7, 0xCE,\n\
      \                0x9C, 0x39, 0x73, 0xE6, 0xCC, 0x98, 0x31, 0x62, 0xC5, 0x8B,\
      \ 0x16, 0x2D, 0x5A, 0xB4, 0x69, 0xD2,\n                0xA4, 0x48, 0x91, 0x22,\
      \ 0x45, 0x8A, 0x14, 0x29, 0x52, 0xA5, 0x4A, 0x95, 0x2A, 0x54, 0xA9, 0x53,\n\
      \                0xA7, 0x4E, 0x9D, 0x3B, 0x77, 0xEE, 0xDD, 0xBB, 0x76, 0xEC,\
      \ 0xD9, 0xB3, 0x67, 0xCF, 0x9E, 0x3D,\n                0x7B, 0xF7, 0xEF, 0xDF,\
      \ 0xBF, 0x7E, 0xFD, 0xFA, 0xF4, 0xE9, 0xD3, 0xA6, 0x4C, 0x99, 0x33, 0x66,\n\
      \                0xCD, 0x9A, 0x35, 0x6A, 0xD4, 0xA8, 0x51, 0xA3, 0x46, 0x8C,\
      \ 0x18, 0x30, 0x60, 0xC1, 0x83, 0x07,\n                0x0E, 0x1D, 0x3A, 0x75,\
      \ 0xEA, 0xD5, 0xAA, 0x55, 0xAB, 0x57, 0xAF, 0x5F, 0xBE, 0x7C, 0xF9, 0xF2,\n\
      \                0xE5, 0xCA, 0x94, 0x28, 0x50, 0xA1, 0x42, 0x84, 0x09, 0x13,\
      \ 0x27, 0x4F, 0x9F, 0x3F, 0x7F)\n\n# # debug\n# whitening_seq_debug = 0xFF,\
      \ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\n# whitening_seq = whitening_seq_debug\n\nclass\
      \ Whitening(gr.sync_block):\n    def __init__(self):\n        gr.sync_block.__init__(\n\
      \            self,\n            name='LoRa Whitening',\n            in_sig=[np.uint8],\n\
      \            out_sig=[np.uint8]\n        )\n        self.table_idx = 0 # index\
      \ of the whitening table cell to be used for whitening\n        \n    def work(self,\
      \ input_items, output_items):\n        \n        in0 = input_items[0]    # input\
      \ buffer reference\n        out = output_items[0]   # output buffer reference\n\
      \n        input_matrix = np.zeros((len(in0), 4), dtype=np.uint8)\n        for\
      \ i in range(len(in0)):\n            bits_crop = [int(x) for x in bin(in0[i])[2:]]\
      \                   # convert to binary\n            bits_crop_norm = ([0]*(4-len(bits_crop))\
      \ + bits_crop)[-(4):]    # crop to 4 useful bits\n            input_matrix[i][:]\
      \ = np.asarray(bits_crop_norm, dtype=np.uint8) # convert to np.array\n     \
      \       \n            \n            out[i] = in0[i] ^ whitening_seq[self.table_idx]\
      \ # whiten (XOR) the input vector\n\n            self.table_idx += 1       \
      \                  # increment table index\n            if(self.table_idx ==\
      \ len(whitening_seq)):   # if table index is out of bounds, reset it\n     \
      \           self.table_idx = 0\n\n        # # debug\n        # print(\"\\n---\
      \ GENERAL WORK : WHITENING ---\")\n        # print(\"in0 :\")\n        # print(in0)\n\
      \        # print(\"input_matrix :\")\n        # print(input_matrix)\n      \
      \  # print(\"out :\")\n        # print(out)\n        # print(\"return len(out):\
      \ \")\n        # print(len(out))\n        # print(\"--- WHITENING END---\")\n\
      \n        return len(out)\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('LoRa Whitening', 'Whitening', [], [('0', 'byte', 1)], [('0', 'byte',
      1)], '', [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [312, 440.0]
    rotation: 0
    state: enabled
- name: epy_block_1_1
  id: epy_block
  parameters:
    CR: CR
    _source_code: "\"\"\"\nHamming encoding block\nForward Error Correction encoding\
      \ block.\nReference : \"MIT EECS II : http://web.mit.edu/6.02/www/f2012/handouts/L05_slides.pdf\"\
      \n\nINPUT:\n    - in_sig[0]: binary input sequence (4 useful bits per byte)\n\
      OUTPUT:\n    - out_sig[0]: binary output sequence (4+CR useful bits per byte)\n\
      \"\"\"\n\nimport numpy as np\nfrom gnuradio import gr\n\n\nclass HammingTx(gr.sync_block):\n\
      \    def __init__(self, CR = 4):\n        gr.sync_block.__init__(\n        \
      \    self,\n            name='LoRa Hamming Tx',\n            in_sig=[np.uint8],\n\
      \            out_sig=[np.uint8]\n        )\n        self.CR = CR\n\n    def\
      \ work(self, input_items, output_items):\n        \n        in0 = input_items[0]\
      \    # input buffer reference\n        out = output_items[0]   # output buffer\
      \ reference\n    \n        output_matrix = np.zeros((len(in0), 4+self.CR), dtype=np.uint8)\n\
      \        input_matrix = np.zeros((len(in0), 4), dtype=np.uint8)\n\n        #\
      \ Hamming encoding (iterate over matrix lines and encode each)\n        for\
      \ i in range(len(in0)):\n            bits_crop = [int(x) for x in bin(in0[i])[2:]]\
      \                   # convert to binary    \n            bits_crop_norm = ([0]*(4-len(bits_crop))\
      \ + bits_crop)[-(4):]    # crop to 4 bits\n            input_matrix[i][:] =\
      \ np.asarray(bits_crop_norm, dtype=np.uint8) # convert to np.array\n\n     \
      \       if self.CR == 1: # CR = 1, add one parity bit\n                p0 =\
      \ input_matrix[i][0] ^ input_matrix[i][1] ^ input_matrix[i][2] ^ input_matrix[i][3]\n\
      \                output_matrix[i] = np.asarray([input_matrix[i][0], input_matrix[i][1],\
      \ input_matrix[i][2], input_matrix[i][3], p0], dtype=np.uint8)\n\n         \
      \   if self.CR == 2: # CR = 2, add two parity bits\n                p0 = input_matrix[i][0]\
      \ ^ input_matrix[i][1] ^ input_matrix[i][2]\n                p1 = input_matrix[i][1]\
      \ ^ input_matrix[i][2] ^ input_matrix[i][3]\n                output_matrix[i]\
      \ = np.asarray([input_matrix[i][0], input_matrix[i][1], input_matrix[i][2],\
      \ input_matrix[i][3], p1, p0], dtype=np.uint8)\n\n            if self.CR ==\
      \ 3: # CR = 3, add three parity bits (Hamming(7,4))\n                Q = np.array([[0,1,1,1],\
      \ [1,1,0,1], [1,1,1,0], [1,0,1,1]], np.uint8) \n                Id = np.identity(4,\
      \ dtype=np.uint8)\n                G = np.concatenate((Id, Q),axis=1)  # generator\
      \ matrix\n                output_matrix[i] = (np.dot(input_matrix[i],G)%2)[0:4+self.CR]\n\
      \n            if self.CR == 4: # CR = 4, add four parity bits (Hamming(8,4))\n\
      \                Q = np.array([[0,1,1,1], [1,1,0,1], [1,1,1,0], [1,0,1,1]],\
      \ np.uint8)\n                Id = np.identity(4, dtype=np.uint8)\n         \
      \       G = np.concatenate((Id, Q),axis=1)  # generator matrix\n           \
      \     output_matrix[i] = (np.dot(input_matrix[i],G)%2)\n\n        # binary to\
      \ decimal conversion\n        out[:] = output_matrix.dot(1 << np.arange(output_matrix.shape[-1]\
      \ - 1, -1, -1))\n\n        # #debug\n        # print(\"\\n--- GENERAL WORK :\
      \ HAMMING_ENC ---\")\n        # print(\"in0 :\")\n        # print(in0)\n   \
      \     # print(\"input_matrix :\")\n        # print(input_matrix)\n        #\
      \ print(\"output_matrix :\")\n        # print(output_matrix)\n        # print(\"\
      out :\")\n        # print(out)\n        # print(\"--- HAMMING_ENC END---\")\n\
      \n        return len(output_items[0])\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('LoRa Hamming Tx', 'HammingTx', [('CR', '4')], [('0', 'byte', 1)],
      [('0', 'byte', 1)], '', ['CR'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [488, 436.0]
    rotation: 0
    state: enabled
- name: epy_block_2
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nDewhitening block\nRemove white noise from the signal\n\
      \nINPUT:\n    - in_sig[0]: whitened binary input sequence\nOUTPUT:\n    - out_sig[0]:\
      \ output binary sequence with white noise removed\n\"\"\"\n\nimport numpy as\
      \ np\nfrom gnuradio import gr\n\nwhitening_seq =(0xFF, 0xFE, 0xFC, 0xF8, 0xF0,\
      \ 0xE1, 0xC2, 0x85, 0x0B, 0x17, 0x2F, 0x5E, 0xBC, 0x78, 0xF1, 0xE3,\n      \
      \          0xC6, 0x8D, 0x1A, 0x34, 0x68, 0xD0, 0xA0, 0x40, 0x80, 0x01, 0x02,\
      \ 0x04, 0x08, 0x11, 0x23, 0x47,\n                0x8E, 0x1C, 0x38, 0x71, 0xE2,\
      \ 0xC4, 0x89, 0x12, 0x25, 0x4B, 0x97, 0x2E, 0x5C, 0xB8, 0x70, 0xE0,\n      \
      \          0xC0, 0x81, 0x03, 0x06, 0x0C, 0x19, 0x32, 0x64, 0xC9, 0x92, 0x24,\
      \ 0x49, 0x93, 0x26, 0x4D, 0x9B,\n                0x37, 0x6E, 0xDC, 0xB9, 0x72,\
      \ 0xE4, 0xC8, 0x90, 0x20, 0x41, 0x82, 0x05, 0x0A, 0x15, 0x2B, 0x56,\n      \
      \          0xAD, 0x5B, 0xB6, 0x6D, 0xDA, 0xB5, 0x6B, 0xD6, 0xAC, 0x59, 0xB2,\
      \ 0x65, 0xCB, 0x96, 0x2C, 0x58,\n                0xB0, 0x61, 0xC3, 0x87, 0x0F,\
      \ 0x1F, 0x3E, 0x7D, 0xFB, 0xF6, 0xED, 0xDB, 0xB7, 0x6F, 0xDE, 0xBD,\n      \
      \          0x7A, 0xF5, 0xEB, 0xD7, 0xAE, 0x5D, 0xBA, 0x74, 0xE8, 0xD1, 0xA2,\
      \ 0x44, 0x88, 0x10, 0x21, 0x43,\n                0x86, 0x0D, 0x1B, 0x36, 0x6C,\
      \ 0xD8, 0xB1, 0x63, 0xC7, 0x8F, 0x1E, 0x3C, 0x79, 0xF3, 0xE7, 0xCE,\n      \
      \          0x9C, 0x39, 0x73, 0xE6, 0xCC, 0x98, 0x31, 0x62, 0xC5, 0x8B, 0x16,\
      \ 0x2D, 0x5A, 0xB4, 0x69, 0xD2,\n                0xA4, 0x48, 0x91, 0x22, 0x45,\
      \ 0x8A, 0x14, 0x29, 0x52, 0xA5, 0x4A, 0x95, 0x2A, 0x54, 0xA9, 0x53,\n      \
      \          0xA7, 0x4E, 0x9D, 0x3B, 0x77, 0xEE, 0xDD, 0xBB, 0x76, 0xEC, 0xD9,\
      \ 0xB3, 0x67, 0xCF, 0x9E, 0x3D,\n                0x7B, 0xF7, 0xEF, 0xDF, 0xBF,\
      \ 0x7E, 0xFD, 0xFA, 0xF4, 0xE9, 0xD3, 0xA6, 0x4C, 0x99, 0x33, 0x66,\n      \
      \          0xCD, 0x9A, 0x35, 0x6A, 0xD4, 0xA8, 0x51, 0xA3, 0x46, 0x8C, 0x18,\
      \ 0x30, 0x60, 0xC1, 0x83, 0x07,\n                0x0E, 0x1D, 0x3A, 0x75, 0xEA,\
      \ 0xD5, 0xAA, 0x55, 0xAB, 0x57, 0xAF, 0x5F, 0xBE, 0x7C, 0xF9, 0xF2,\n      \
      \          0xE5, 0xCA, 0x94, 0x28, 0x50, 0xA1, 0x42, 0x84, 0x09, 0x13, 0x27,\
      \ 0x4F, 0x9F, 0x3F, 0x7F)\n\n# # debug\n# whitening_seq_debug = 0xFF, 0xFF,\
      \ 0xFF, 0xFF, 0xFF, 0xFF\n# whitening_seq = whitening_seq_debug\n\nclass LoraDewhitening(gr.sync_block):\n\
      \    def __init__(self):\n        gr.sync_block.__init__(\n            self,\n\
      \            name='LoRa Dewhitening',\n            in_sig=[np.uint8],\n    \
      \        out_sig=[np.uint8]\n        )\n        self.table_idx = 0 # index of\
      \ the whitening table cell to be used for whitening\n        \n    def work(self,\
      \ input_items, output_items):\n\n        in0 = input_items[0]    # input buffer\n\
      \        out = output_items[0]   # output buffer\n\n        input_matrix = np.zeros((len(in0),\
      \ 4), dtype=np.uint8)\n        for i in range(len(in0)):\n            bits_crop\
      \ = [int(x) for x in bin(in0[i])[2:]]                   # convert to binary\n\
      \            bits_crop_norm = ([0]*(4-len(bits_crop)) + bits_crop)[-(4):]  \
      \  # crop to 4 useful bits\n            input_matrix[i][:] = np.asarray(bits_crop_norm,\
      \ dtype=np.uint8) # convert to np.array\n            \n            out_temp\
      \ = in0[i] ^ whitening_seq[self.table_idx]   # dewhitening\n\n            bits_out_temp_crop\
      \ = [int(x) for x in bin(out_temp)[2:]]                                # convert\
      \ to binary\n            bits_out_temp_crop_norm = ([0]*(4-len(bits_out_temp_crop))\
      \ + bits_out_temp_crop)[-(4):] # crop to 4 useful bits\n\n            # binary\
      \ to decimal conversion\n            output_items[0][i] = np.array(bits_out_temp_crop_norm).dot(1\
      \ << np.arange(np.array(bits_out_temp_crop_norm).shape[-1] - 1, -1, -1))\n\n\
      \            self.table_idx += 1                         # increment table index\n\
      \            if(self.table_idx == len(whitening_seq)):   # if table index is\
      \ out of bounds, reset it\n                self.table_idx = 0\n\n        # #\
      \ debug\n        # print(\"\\n--- GENERAL WORK : DEWHITENING ---\")\n      \
      \  # print(\"in0 :\")\n        # print(in0)\n        # print(\"input_matrix\
      \ :\")\n        # print(input_matrix)\n        # print(\"out :\")\n        #\
      \ print(output_items[0][:])\n        # print(\"return len(out): \")\n      \
      \  # print(len(output_items[0]))\n        # print(\"--- DEWHITENING END---\"\
      )\n        \n        return len(output_items[0])"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('LoRa Dewhitening', 'LoraDewhitening', [], [('0', 'byte', 1)], [('0',
      'byte', 1)], '', [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [896, 984.0]
    rotation: 0
    state: enabled
- name: epy_block_3
  id: epy_block
  parameters:
    SF: '9'
    _source_code: "\"\"\"\nPreamble Generation Block:\nReference : \"Towards an SDR\
      \ implementation of LoRa...\" 2020 A.Marquet, N.Montavont, G.Papadopoulos)\n\
      \nINPUT:\n    - None\nOUTPUT:\n    - out_sig[0]: IQ complex vector, length =\
      \ M * os_factor * (preamble_len + 2.25)\n\"\"\"\n\nimport numpy as np\nfrom\
      \ gnuradio import gr\nimport math\n\ndef modulate_vect(SF, id, os_factor) :\n\
      \    M  = pow(2,SF)\n    chirp = np.zeros((len(id),M*os_factor), dtype=np.complex64)\n\
      \n    for i in range(len(id)) :\n        n_fold = M * os_factor - id[i] * os_factor\n\
      \        for n in range(0,M*os_factor):\n            if n < n_fold:\n      \
      \          chirp[i][n] = np.exp(2j*math.pi *(n*n/(2*M)/pow(os_factor,2)+(id[i]/M-0.5)*n/os_factor))\n\
      \            else:\n                chirp[i][n] = np.exp(2j*math.pi *(n*n/(2*M)/pow(os_factor,2)+(id[i]/M-1.5)*n/os_factor))\n\
      \    return chirp\n\nclass PreambleGenerator(gr.sync_block):\n\n    def __init__(self,\
      \ SF = 9, preamble_len = 6):\n        gr.sync_block.__init__(\n            self,\n\
      \            name='LoRa Preamble Generator',\n            in_sig=None,\n   \
      \         out_sig=[(np.complex64,round(pow(2,SF)*(preamble_len+2.25)))]   #\
      \ !!! will cause problem if os_factor > 1 !!! \n        )\n        self.SF =\
      \ SF\n        self.preamble_len = preamble_len\n\n    def work(self, input_items,\
      \ output_items):\n\n        preamble_up = np.reshape(modulate_vect(self.SF,\
      \ [0]*self.preamble_len, 1), -1)      # generate preamble_len upchirps\n   \
      \     preamble_down = np.reshape(np.conjugate(modulate_vect(self.SF, [0]*3,\
      \ 1)), -1)      # generate 3 downchirps\n        preamble = np.concatenate((preamble_up,\
      \ preamble_down[0:int(2.25*pow(2,self.SF))])) # concatenate preamble_up and\
      \ preamble_down[0:2.25*M]\n        output_items[0][0] = np.reshape(preamble,-1)\
      \                                        # reshape preamble to a vector\n\n\
      \        return len(output_items[0])"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    preamble_len: preamble_len
  states:
    _io_cache: ('LoRa Preamble Generator', 'PreambleGenerator', [('SF', '9'), ('preamble_len',
      '6')], [], [('0', 'complex', 4224)], '', ['SF', 'preamble_len'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [752, 364.0]
    rotation: 0
    state: enabled
- name: epy_block_4
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nEmbedded Python Blocks:\n\nEach time this file is saved,\
      \ GRC will instantiate the first class it finds\nto get ports and parameters\
      \ of your block. The arguments to __init__  will\nbe the parameters. All of\
      \ them are required to have default values!\n\"\"\"\n\nimport numpy as np\n\
      from gnuradio import gr\n\nclass my_basic_adder_block(gr.basic_block):\n   \
      \ # def __init__(self):\n    #     gr.basic_block.__init__(self,\n    #    \
      \     name=\"test_blqsdock\",\n    #         in_sig=[np.uint8],\n    #     \
      \    out_sig=[np.uint8])\n\n    # def forecast(self, noutput_items, ninputs)\
      \ :\n    #     ninput_items_required = [0]*ninputs #ninput_items_required[i]\
      \ is the number of items that will be consumed on input port i\n    #     for\
      \ i in range(ninputs):\n    #         ninput_items_required[i] = 1.5 * noutput_items\
      \ * ninputs\n\n    #     # print(\"--- FORECAST ---\")\n    #     # print(ninputs)\n\
      \    #     # print(noutput_items)\n    #     # print(ninput_items_required)\n\
      \n    #     return ninput_items_required\n\n\n    # def general_work(self, input_items,\
      \ output_items):\n        \n    #     #buffer references\n    #     in0 = input_items[0][:len(output_items[0])]\n\
      \    #     out = output_items[0]\n        \n\n    #     output_items[0][:] =\
      \ in0\n\n\n    #     print(\"\\n--- GENERAL WORK 1  ---\")\n    #     print(\"\
      input_items[0]\")\n    #     print(input_items[0])\n    #     print(\"in0\"\
      )\n    #     print(in0)\n    #     print(\"len(in0)\")\n    #     print(len(in0))\n\
      \    #     print(\"output_items[0]\")\n    #     print(output_items[0])\n  \
      \  #     print(\"len(output_items[0])\")\n    #     print(len(output_items[0]))\n\
      \n    #     #consume the inputs\n    #     self.consume(0, len(in0)) #consume\
      \ port 0 input\n    #     # self.produce(0, 1) #produce 3 items on port 0\n\
      \    #     #return produced\n    #     return len(output_items[0])\n\n   def\
      \ __init__(self, input_buffer_len=2):\n      gr.basic_block.__init__(self,\n\
      \         name=\"sync_test\",\n         in_sig=[np.uint8],\n         out_sig=[np.uint8])\n\
      \      self.input_buffer_len = input_buffer_len\n\n   def forecast(self, noutput_items,\
      \ ninputs):\n    #   print(\"FORECAST START\")\n      ninput_items_required\
      \ = [self.input_buffer_len] * ninputs\n    #   print(\"len(ninput_items_required),noutput_items\"\
      ,len(ninput_items_required),noutput_items)\n    #   print(\"FORECAST END\")\n\
      \      return ninput_items_required\n\n   def general_work(self, input_items,\
      \ output_items):\n    print(\"\\n--- GENERAL WORK START ---\")\n    if(len(input_items[0])\
      \ >= self.input_buffer_len) :\n        out_vect = [0xFF, 0x55, 0xAA]\n     \
      \   output_items[0][0:len(out_vect)] = out_vect\n        self.consume(0, self.input_buffer_len)\n\
      \        self.produce(0, len(out_vect))\n\n\n        print(\"len(input_items)\"\
      , len(input_items[0]))\n        print(\"input_buffer_len\", self.input_buffer_len)\n\
      \        print(\"len(input_items[0]) >= input_buffer_len\")\n        print(\"\
      len(output_items[0])\", len(output_items[0]))\n        print(\"output_items[0]\
      \ = \")\n        print(output_items[0])\n\n    print(\"--- GENERAL WORK END\
      \ ---\")\n    return len(out_vect)"
    affinity: ''
    alias: ''
    comment: ''
    input_buffer_len: '2'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('sync_test', 'my_basic_adder_block', [('input_buffer_len', '2')],
      [('0', 'byte', 1)], [('0', 'byte', 1)], '', ['input_buffer_len'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1192, 52.0]
    rotation: 0
    state: disabled
- name: epy_block_5
  id: epy_block
  parameters:
    B: '250000'
    SF: SF
    _source_code: "\"\"\"\nDemodulation Block:\nReference : \"Towards an SDR implementation\
      \ of LoRa...\" 2020 A.Marquet, N.Montavont, G.Papadopoulos)\n\nINPUT:\n    -\
      \ in_sig[0]: IQ complex vectors input sequence\nOUTPUT:\n    - out_sig[0]: \n\
      \"\"\"\n\nimport numpy as np\nfrom gnuradio import gr\nimport math\n\ndef modulate(SF,\
      \ id, os_factor) :\n    M  = pow(2,SF)\n    n_fold = M * os_factor - id * os_factor\n\
      \    chirp = np.zeros(M*os_factor, dtype=np.complex64)\n    for n in range(0,M*os_factor):\n\
      \        if n < n_fold:\n            chirp[n] = np.exp(2j*math.pi *(n*n/(2*M)/pow(os_factor,2)+(id/M-0.5)*n/os_factor))\n\
      \        else:\n            chirp[n] = np.exp(2j*math.pi *(n*n/(2*M)/pow(os_factor,2)+(id/M-1.5)*n/os_factor))\n\
      \    return chirp\n\nclass Demodulation(gr.sync_block):\n\n    def __init__(self,\
      \ SF = 9, B = 250000):\n        gr.sync_block.__init__(\n            self,\n\
      \            name='LoRa Demodulation',\n            in_sig=[(np.complex64,pow(2,SF))],\n\
      \            out_sig=[np.uint32]\n        )\n        self.SF = SF\n        self.B\
      \ = B\n\n    def work(self, input_items, output_items):\n\n        M = pow(2,self.SF)\n\
      \        base_upchirp = modulate(self.SF, 0, 1)\n        base_downchirp = np.conjugate(base_upchirp)\n\
      \n        symbols_hat =  np.zeros(len(input_items[0]), dtype=np.uint32)\n  \
      \      for i in range(len(input_items[0])):\n            demod_signal = np.multiply(input_items[0][i],\
      \ base_downchirp)   # multiply every symbol with the downchirp\n           \
      \ demod_signal_fft = np.fft.fft(demod_signal)                     # perform\
      \ FFT on demodulated signal    \n            idx = np.argmax(np.abs(demod_signal_fft))\
      \                       # find the frequency index of the maximum value\n  \
      \          freq_vect = np.arange(0,M-1)*(self.B/M)                         #\
      \ !!!! WILL INTRODUCE PROBLEMS WHEN OS_FACTOR IS NOT 1 !!!!\n            symbols_hat[i]\
      \ = round(freq_vect[idx]*M/self.B)                 # convert the frequency index\
      \ to symbol index\n            output_items[0][i] = symbols_hat[i]\n       \
      \     \n        \n        # debug\n        print(\"\\n--- GENERAL WORK : DEMODULATION\
      \ ---\")\n        print(\"symbols_hat :\")\n        print(symbols_hat)\n\n \
      \       return len(output_items[0])\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('LoRa Demodulation', 'Demodulation', [('SF', '9'), ('B', '250000')],
      [('0', 'complex', 512)], [('0', 'int', 1)], '', ['B', 'SF'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [352, 972.0]
    rotation: 0
    state: enabled
- name: epy_block_6
  id: epy_block
  parameters:
    SF: SF
    _source_code: "\"\"\"\nFrame sync block:\nTries to find a correlation peak between\
      \ the input sequence and a reference sequence (preamble). If found, tag the\
      \ end of preamble.\n\nINPUTS:\n    - in_sig[0]: IQ complex input stream\n  \
      \  - in_sig[1]: IQ complex reference vector (preamble)\nOUTPUT:\n    - out_sig[0]:\
      \ IQ complex stream\n\"\"\"\n\n\nimport numpy as np\nfrom gnuradio import gr\n\
      import pmt\n\nclass Frame_sync(gr.basic_block):\n    def __init__(self, SF=9,\
      \ preamble_len = 6, frame_length = 18):\n        gr.basic_block.__init__(self,\n\
      \            name=\"LoRa Frame Detector\",\n            in_sig=[np.complex64,(np.complex64,\
      \ round(pow(2,SF)*(preamble_len+2.25)))], # first input is the input signal,\
      \ second is the preamble to be correlated with\n            # out_sig=[(np.complex64,pow(2,SF))])\n\
      \            out_sig=[(np.complex64)])\n        self.SF = SF\n        self.full_preamble_length\
      \ = round(pow(2,SF)*(preamble_len+2.25))\n        self.frame_length = round(pow(2,SF)*(frame_length))\n\
      \n    def forecast(self, noutput_items, ninputs) :\n        ninput_items_required\
      \ = [1]*ninputs #ninput_items_required[i] is the number of items that will be\
      \ consumed on input port i\n        return ninput_items_required\n\n    def\
      \ general_work(self, input_items, output_items):\n\n        # buffer references\n\
      \        in0 = input_items[0] # input signal\n        in1 = input_items[1] #\
      \ preamble to be correlated with\n        out = output_items[0] # output buffer\n\
      \n        corr = np.correlate(in0[:], in1[0]) # correlate input signal with\
      \ preamble\n        peak = np.max(corr)                 # find the correlation\
      \ peak\n        threshold = 2000                    # threshold for peak detection\n\
      \n        # # debug\n        # print(\"\\n--- Correlator ---\")\n        # print(\"\
      Peak: \", peak)\n        # print(\"Peak Index: \", peakIndex)\n        # print(\"\
      output_items[0]: \", len(output_items[0]))\n\n        if peak > threshold :\n\
      \            # print(\"peak > threshold\")\n            peak_index = np.argmax(corr)\
      \         # get index of the peak\n            # add tag at the end of the preamble,\
      \ write frame_length inside so Tagged Stream Cropper block can remove preamble\n\
      \            self.add_item_tag(0, self.nitems_written(0) + peak_index + self.full_preamble_length,\
      \  pmt.intern(\"preamble_end\"),  pmt.intern(str(self.frame_length)))\n\n  \
      \      out[0:len(in0)] = in0[:len(out)]\n        self.consume(0, len(in0[:len(out)]))\n\
      \        return len(in0[:len(out)])"
    affinity: ''
    alias: ''
    comment: ''
    frame_length: frame_len
    maxoutbuf: '0'
    minoutbuf: '0'
    preamble_len: preamble_len
  states:
    _io_cache: ('LoRa Frame Detector', 'Frame_sync', [('SF', '9'), ('preamble_len',
      '6'), ('frame_length', '18')], [('0', 'complex', 1), ('1', 'complex', 4224)],
      [('0', 'complex', 1)], '', ['SF', 'frame_length'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [560, 676.0]
    rotation: 0
    state: enabled
- name: epy_block_6_0
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nTagged Stream Cropper:\nReference : https://dsp.stackexchange.com/questions/80751/gnu-radiotagged-stream-how-to-clip-the-stream-as-packet-length-tag-long\n\
      \nINPUTS:\n    - in_sig[0]: IQ complex stream\nOUTPUT:\n    - out_sig[0]: IQ\
      \ complex stream\n\"\"\"\n\nimport numpy as np\nfrom gnuradio import gr\nimport\
      \ pmt\n\nclass my_basic_adder_block(gr.basic_block):\n    def __init__(self,tag_name\
      \ = 'packet_len'):\n        gr.basic_block.__init__(self,\n                \
      \                name=\"Tagged Stream Cropper\",\n                         \
      \       in_sig  = [np.complex64],\n                                out_sig =\
      \ [np.complex64])\n\n        self.previous_tag_n_remainder = 0\n        self.tag_name\
      \                 = tag_name\n        self.set_tag_propagation_policy(gr.TPP_DONT)\n\
      \n    def general_work(self, input_items, output_items):\n        len_out =\
      \ len(output_items[0])\n\n        # DO PROCESSING\n        out_produced = 0\
      \ # output produced \n\n        #-> Write the remaining data of the previous\
      \ tag\n        if self.previous_tag_n_remainder > 0: \n            if self.previous_tag_n_remainder\
      \ < len_out: # if the length of the input items is sufficient to write the remainder\
      \ of the previous tag items \n                output_items[0][:self.previous_tag_n_remainder]\
      \ = input_items[0][:self.previous_tag_n_remainder] #write to output \n     \
      \           out_produced                                   += self.previous_tag_n_remainder\
      \                  #inccrease the number of item produced\n                self.previous_tag_n_remainder\
      \ = 0                                                                #reset\
      \ the counter \n                # the RETURN is at the end of the work()\n\n\
      \            else: # self.previous_tag_n_remainder >= len_out\n            \
      \    output_items[0][:len_out]      = input_items[0][:len_out]\n           \
      \     self.previous_tag_n_remainder -= len_out\n                self.consume(0,\
      \ len_out)\n                return len_out\n\n        # READ TAGS AND PARSE\
      \ THE RECEIVED STREAM\n        tags = self.get_tags_in_window(0, out_produced,\
      \ len_out)\n\n        #if there exist tag\n        if len(tags) > 0:\n     \
      \       #for each tag apply\n            for tag in tags:\n                tag_name\
      \   = pmt.to_python(tag.key)            # packet_tag\n                tag_len\
      \    = int(pmt.to_python(tag.value))          # packet_len\n               \
      \ tag_pos    = tag.offset - self.nitems_read(0)  # packet_position_index\n \
      \               if tag_name == self.tag_name:       #check if the tag name is\
      \ appropriate\n                    if tag_pos + tag_len < len_out: # if all\
      \ the elements correspding to the \"tag\" are included in the input_items\n\n\
      \                        # write the elements to the output\n              \
      \          output_items[0][out_produced:(out_produced+tag_len)] = input_items[0][tag_pos:(tag_pos+tag_len)]\n\
      \n                        # add tag to the corresponding start point       \
      \              \n                        self.add_item_tag(0,              \
      \                     # Write to output port 0\n                           \
      \              self.nitems_written(0)+out_produced,  # Index of the tag in absolute\
      \ terms\n                                         tag.key,                 \
      \             # Key of the tag\n                                         tag.value\
      \                             # Value of the tag\n                         \
      \                )\n                        #increase the number of output element\
      \ produced counter\n                        out_produced += tag_len\n\n    \
      \                else: #tag_pos+tag_len >= len_out:\n                      \
      \  n_item_to_wrt = len_out - tag_pos\n                        output_items[0][out_produced:(out_produced\
      \ + n_item_to_wrt)] = input_items[0][tag_pos:(tag_pos+n_item_to_wrt)]\n\n  \
      \                      self.add_item_tag(0,                                \
      \     # Write to output port 0\n                                          self.nitems_written(0)+out_produced,\
      \   # Index of the tag in absolute terms\n                                 \
      \         tag.key,                               # Key of the tag\n        \
      \                                  tag.value                              #\
      \ Value of the tag\n                                          )\n\n        \
      \                self.previous_tag_n_remainder = tag_len - n_item_to_wrt\n \
      \                       out_produced                 += n_item_to_wrt\n    \
      \                    self.consume(0,len_out)\n                        return\
      \ out_produced\n\n        #if there is no tag exits\n        self.consume(0,len_out)\n\
      \n        #recall that the first \"if\" state is producing element!\n      \
      \  return out_produced\n\n# \"\"\"\n# Preamble removal block\n# Correlation\
      \ method\n# \"\"\"\n\n# import numpy as np\n# from gnuradio import gr\n# import\
      \ pmt\n\n# class Preamble_Remover(gr.basic_block):\n#     def __init__(self,\
      \ SF=9, preamble_len = 6):\n#         gr.basic_block.__init__(self,\n#     \
      \        name=\"LoRa Preamble Remover\",\n#             in_sig=[(np.complex64)],\n\
      #             out_sig=[(np.complex64)])\n#         self.SF = SF\n\n#     def\
      \ forecast(self, noutput_items, ninputs) :\n#         ninput_items_required\
      \ = [1]*ninputs #ninput_items_required[i] is the number of items that will be\
      \ consumed on input port i\n#         return ninput_items_required\n\n#    \
      \ def general_work(self, input_items, output_items):\n\n#         #buffer references\n\
      #         in0 = input_items[0] #input signal\n\n#         tags = self.get_tags_in_window(0,\
      \ 0, len(input_items[0]))\n#         for tag in tags:\n#             key = pmt.to_python(tag.key)\
      \ # convert from PMT to python string\n#             value = pmt.to_python(tag.value)\
      \ # Note that the type(value) can be several things, it depends what PMT type\
      \ it was\n#             print('key:', key)\n#             print('value:', value,\
      \ type(value))\n#             print('')\n#             croppedInput = in0[int(value):]\n\
      #             output_items[0][0:len(in0)] = croppedInput[:len(output_items[0])]\n\
      #             self.consume(0, len(in0[:len(output_items[0])]))\n#         return\
      \ len(in0[:len(output_items[0])])"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    tag_name: '"preamble_end"'
  states:
    _io_cache: ('Tagged Stream Cropper', 'my_basic_adder_block', [('tag_name', "'packet_len'")],
      [('0', 'complex', 1)], [('0', 'complex', 1)], '', ['tag_name'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [976, 692.0]
    rotation: 0
    state: enabled
- name: epy_block_6_0_0_0_0_0
  id: epy_block
  parameters:
    SF: SF
    _source_code: "\"\"\"\nModulation Block:\nReference : \"Towards an SDR implementation\
      \ of LoRa...\" 2020 A.Marquet, N.Montavont, G.Papadopoulos)\n\nINPUT:\n    -\
      \ in_sig[0]: int32 input stream\nOUTPUT:\n    - out_sig[0]: IQ complex vectors\
      \ output stream\n\"\"\"\n\nimport numpy as np\nfrom gnuradio import gr\nimport\
      \ math\n\ndef modulate(SF, id, os_factor) :\n    M  = pow(2,SF)\n    n_fold\
      \ = M * os_factor - id * os_factor\n    chirp = np.zeros(M*os_factor, dtype=np.complex64)\n\
      \    for n in range(0,M*os_factor):\n        if n < n_fold:\n            chirp[n]\
      \ = np.exp(2j*math.pi *(n*n/(2*M)/pow(os_factor,2)+(id/M-0.5)*n/os_factor))\n\
      \        else:\n            chirp[n] = np.exp(2j*math.pi *(n*n/(2*M)/pow(os_factor,2)+(id/M-1.5)*n/os_factor))\n\
      \    return chirp\n\nclass Modulation(gr.sync_block):\n\n    def __init__(self,\
      \ SF = 9):\n        gr.sync_block.__init__(\n            self,\n           \
      \ name='LoRa Modulation',\n            in_sig=[np.uint32],\n            out_sig=[(np.complex64,pow(2,SF))]\n\
      \        )\n        self.SF = SF\n\n    def work(self, input_items, output_items):\n\
      \n        symbols = input_items[0]\n        for i in range (len(symbols)) :\n\
      \            output_items[0][i] = modulate(self.SF, symbols[i], 1)   # modulate\
      \ every symbol\n\n        # debug\n        print(\"\\n--- GENERAL WORK : MODULATION\
      \ ---\")\n        print(\"symbols :\")\n        print(symbols)\n\n        return\
      \ len(output_items[0])"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('LoRa Modulation', 'Modulation', [('SF', '9')], [('0', 'int', 1)],
      [('0', 'complex', 512)], '', ['SF'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [808, 436.0]
    rotation: 0
    state: enabled

connections:
- [blocks_stream_mux_1, '0', epy_block_6, '0']
- [blocks_stream_to_vector_0, '0', epy_block_5, '0']
- [blocks_tagged_stream_align_1, '0', epy_block_6_0, '0']
- [blocks_vector_source_x_0, '0', blocks_stream_mux_1, '0']
- [blocks_vector_source_x_0_0_0_0, '0', blocks_file_sink_0_3, '0']
- [blocks_vector_source_x_0_0_0_0, '0', epy_block_1_0_0, '0']
- [blocks_vector_source_x_0_1, '0', epy_block_4, '0']
- [blocks_vector_to_stream_0_0_0, '0', blocks_file_sink_4, '0']
- [blocks_vector_to_stream_0_0_0, '0', blocks_stream_mux_1, '1']
- [blocks_vector_to_stream_0_0_1, '0', blocks_stream_mux_1, '2']
- [epy_block_0, '0', epy_block_1, '0']
- [epy_block_0_1_0_0, '0', epy_block_6_0_0_0_0_0, '0']
- [epy_block_1, '0', epy_block_2, '0']
- [epy_block_1_0_0, '0', epy_block_1_1, '0']
- [epy_block_1_1, '0', epy_block_0_1_0_0, '0']
- [epy_block_2, '0', blocks_file_sink_0_1, '0']
- [epy_block_3, '0', blocks_vector_to_stream_0_0_0, '0']
- [epy_block_3, '0', epy_block_6, '1']
- [epy_block_4, '0', blocks_file_sink_0_0, '0']
- [epy_block_5, '0', epy_block_0, '0']
- [epy_block_6, '0', blocks_file_sink_1, '0']
- [epy_block_6, '0', blocks_tagged_stream_align_1, '0']
- [epy_block_6_0, '0', blocks_file_sink_2_0, '0']
- [epy_block_6_0, '0', blocks_stream_to_vector_0, '0']
- [epy_block_6_0_0_0_0_0, '0', blocks_vector_to_stream_0_0_1, '0']

metadata:
  file_format: 1
